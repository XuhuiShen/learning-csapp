1
00:00:00,000 --> 00:00:00,469
 Youtube subtitles download by mo.dbxdb.com 

2
00:00:00,469 --> 00:00:09,480
okay so let's say picking off we left

3
00:00:03,480 --> 00:00:12,500
off last class bits bytes and integers

4
00:00:09,500 --> 00:00:14,000
okay so remember the last pass we talked

5
00:00:12,000 --> 00:00:16,400
about about standards or representation

6
00:00:14,400 --> 00:00:18,048
right reach bit is nothing more than a

7
00:00:16,048 --> 00:00:20,059
binary digit right and if you want to

8
00:00:18,059 --> 00:00:23,279
know what the value is you sum up each

9
00:00:20,279 --> 00:00:25,580
place right you know you know if there's

10
00:00:23,580 --> 00:00:27,380
a 1 we have the value that plays if

11
00:00:25,380 --> 00:00:28,210
there's a 0 we don't and you just sum

12
00:00:27,210 --> 00:00:30,740
across the whole thing and that gives

13
00:00:28,740 --> 00:00:31,390
you the value of the number we talked

14
00:00:30,390 --> 00:00:34,590
about two's complement which was that

15
00:00:31,590 --> 00:00:36,500
really weird notation right where we

16
00:00:34,500 --> 00:00:40,829
complement that every digit we added 1

17
00:00:36,829 --> 00:00:43,649
and this actually sort of made some

18
00:00:40,649 --> 00:00:46,379
sense because if you do that and you add

19
00:00:43,379 --> 00:00:47,590
a number to its complement you get 0 ok

20
00:00:46,590 --> 00:00:49,850
and we talked about why that actually

21
00:00:47,850 --> 00:00:52,950
works the fact that if you had you know

22
00:00:49,950 --> 00:00:53,110
and the fact that it's the way carryout

23
00:00:52,110 --> 00:00:56,850
works that mean that makes that work in

24
00:00:53,850 --> 00:00:59,340
fact if I take 1 1 1 1 1 1 1 1 1 and I

25
00:00:56,340 --> 00:01:00,879
add 0 I'm sorry I add 1 I get all zeroes

26
00:00:59,879 --> 00:01:04,989
right

27
00:01:00,989 --> 00:01:07,199
meaning that one more woman 1 right is

28
00:01:04,199 --> 00:01:11,799
the additive complement of inverse of 1

29
00:01:07,799 --> 00:01:13,459
and how we built up two's complement

30
00:01:11,459 --> 00:01:16,890
notation from there right all one's plus

31
00:01:13,890 --> 00:01:23,500
1 is 0 so all one's therefore is

32
00:01:16,500 --> 00:01:24,099
negative 1 ok yeah and we talked about

33
00:01:23,099 --> 00:01:26,420
the fact how in two's complement

34
00:01:24,420 --> 00:01:27,130
notation right we start out with the

35
00:01:26,130 --> 00:01:30,659
most negative number one followed by all

36
00:01:27,659 --> 00:01:31,479
zeros and then we add back to that as we

37
00:01:30,479 --> 00:01:33,950
start to turn other digits on and

38
00:01:31,950 --> 00:01:36,688
actually bring ourselves closer to 0

39
00:01:33,688 --> 00:01:38,390
which is why all 1s is negative 1 the

40
00:01:36,390 --> 00:01:44,250
closest integer to 0 because we've added

41
00:01:38,250 --> 00:01:45,069
everything back right ok it's sort of

42
00:01:44,069 --> 00:01:46,270
important to have an intuition as to why

43
00:01:45,270 --> 00:01:48,709
these things work because it really

44
00:01:46,709 --> 00:01:50,720
makes the 213 exams much easier because

45
00:01:48,720 --> 00:01:52,459
you know we're gonna have an exam you

46
00:01:50,459 --> 00:01:54,019
know question that basically asked you

47
00:01:52,019 --> 00:01:56,509
to play with integer numbers you we have

48
00:01:54,509 --> 00:01:58,578
every single semester right for the last

49
00:01:56,578 --> 00:02:00,828
15 years it probably even longer than

50
00:01:58,828 --> 00:02:03,090
that I've been here since 99 I think

51
00:02:00,090 --> 00:02:04,688
this this tradition started in 98 so you

52
00:02:03,688 --> 00:02:06,828
could try to memorize a whole bunch of

53
00:02:04,828 --> 00:02:07,479
bit patterns or you can just have

54
00:02:06,479 --> 00:02:10,890
intuition as to why it works and say

55
00:02:07,890 --> 00:02:13,649
okay if I add 1 to all ones I'm gonna

56
00:02:10,649 --> 00:02:17,470
get 0 therefore all ones

57
00:02:13,470 --> 00:02:20,340
one great if that's negative one and I

58
00:02:17,340 --> 00:02:21,099
take off a 1 that's negative 2 right and

59
00:02:20,099 --> 00:02:23,960
then work your way back do you have a

60
00:02:21,960 --> 00:02:26,130
one and all zeroes it's the most

61
00:02:23,130 --> 00:02:30,759
negative number right it all sort of

62
00:02:26,759 --> 00:02:31,150
makes sense all right and then we talked

63
00:02:30,150 --> 00:02:34,889
about the fact that in these we need a

64
00:02:31,889 --> 00:02:35,020
way to tell two's complement number from

65
00:02:34,020 --> 00:02:38,810
a number that's not two's complement

66
00:02:35,810 --> 00:02:39,280
right if we don't I mean they're all

67
00:02:38,280 --> 00:02:41,449
they're all numbers which way do I

68
00:02:39,449 --> 00:02:45,580
interpret it so the way we interpret it

69
00:02:41,580 --> 00:02:46,120
is that if the leading digit is a 1 we

70
00:02:45,120 --> 00:02:48,860
interpreters two's complement if the

71
00:02:46,860 --> 00:02:52,539
leading digit is a 0 we interpret it as

72
00:02:48,539 --> 00:02:54,410
a regular number and that tells us how

73
00:02:52,410 --> 00:02:56,270
to interpret our result remember the

74
00:02:54,270 --> 00:02:58,910
adder for you know for a regular

75
00:02:56,910 --> 00:03:00,319
representation the adder for two's

76
00:02:58,319 --> 00:03:01,000
complement and the adder for adding a

77
00:03:00,000 --> 00:03:03,169
regular representation to two's

78
00:03:01,169 --> 00:03:04,090
complement are all the same we do the

79
00:03:03,090 --> 00:03:07,470
same thing it's just a bitwise add

80
00:03:04,470 --> 00:03:08,199
that's what's beautiful about this right

81
00:03:07,199 --> 00:03:10,520
that's actually why we originally

82
00:03:08,520 --> 00:03:12,949
invented these notations because it

83
00:03:10,949 --> 00:03:13,389
means that we only need one adder and a

84
00:03:12,389 --> 00:03:17,830
processor we don't need to have

85
00:03:13,830 --> 00:03:19,459
something that's two tracks right I have

86
00:03:17,459 --> 00:03:20,470
positive numbers with one represent a

87
00:03:19,470 --> 00:03:23,459
you can have negative numbers with

88
00:03:20,459 --> 00:03:24,009
another representation I could add using

89
00:03:23,009 --> 00:03:28,660
my adder and if I want to subtract I

90
00:03:24,660 --> 00:03:28,050
generate a 2's complement than that add

91
00:03:30,050 --> 00:03:38,139
took fewer transistors that way okay all

92
00:03:37,139 --> 00:03:39,280
right and so we talked about the fact

93
00:03:38,280 --> 00:03:41,660
that when were that when we're trying to

94
00:03:39,660 --> 00:03:44,729
take I would say a 16-bit number and

95
00:03:41,729 --> 00:03:46,669
represented as a 32-bit number we have

96
00:03:44,669 --> 00:03:48,799
to do sign extension if it's a two's

97
00:03:46,799 --> 00:03:51,000
complement number we need to take those

98
00:03:48,000 --> 00:03:53,389
ones and move them out right if we don't

99
00:03:51,389 --> 00:03:56,430
it's gonna turn into a into a puttan to

100
00:03:53,430 --> 00:03:58,519
a non negative number if we have a non

101
00:03:56,519 --> 00:04:00,919
negative number we need to take those

102
00:03:58,919 --> 00:04:02,470
zeros and copy them on the way out

103
00:04:00,470 --> 00:04:04,729
otherwise if we put if we start putting

104
00:04:02,729 --> 00:04:06,830
in ones it's gonna turn into a into a

105
00:04:04,830 --> 00:04:13,330
two's complement number right as far as

106
00:04:06,330 --> 00:04:15,889
how we interpret it okay all right so

107
00:04:13,889 --> 00:04:17,060
now let's take a look at unsigned

108
00:04:15,060 --> 00:04:19,279
addition I have two numbers U and V and

109
00:04:17,279 --> 00:04:23,790
I add them together here's the question

110
00:04:19,790 --> 00:04:24,399
if I take two unsigned integers and add

111
00:04:23,399 --> 00:04:25,029
them together

112
00:04:24,029 --> 00:04:27,470
what is

113
00:04:25,470 --> 00:04:29,750
the biggest result that I can have and

114
00:04:27,750 --> 00:04:32,190
let's not worry about exactly the number

115
00:04:29,190 --> 00:04:34,069
right let's ask how many bits if I have

116
00:04:32,069 --> 00:04:37,050
2 4 bit numbers and I add them together

117
00:04:34,050 --> 00:04:43,019
in the worst case how many bits do I

118
00:04:37,019 --> 00:04:43,079
need to represent the result yeah 5 y 5

119
00:05:06,079 --> 00:05:11,120
yeah I mean you're exactly right look

120
00:05:08,120 --> 00:05:13,149
with each binary digit right as I move

121
00:05:11,149 --> 00:05:14,279
from my low order digit my ones bit to

122
00:05:13,279 --> 00:05:17,779
my twos bet to my fours bit to my eights

123
00:05:14,779 --> 00:05:19,000
bit to my 16s bit to my 32 bit to my 64

124
00:05:17,000 --> 00:05:23,610
is bit each bit is worth twice the bit

125
00:05:19,610 --> 00:05:26,658
before it right the 64's bit is worth

126
00:05:23,658 --> 00:05:28,569
twice that the 32 bit twice the 16 bit

127
00:05:26,569 --> 00:05:35,550
twice the 8 bit twice the 4-bit twice

128
00:05:28,550 --> 00:05:39,690
the two bit twice the 1 bit right so if

129
00:05:35,690 --> 00:05:43,468
I add if I if I if I take something and

130
00:05:39,468 --> 00:05:47,848
I add it to itself how big is it yell it

131
00:05:43,848 --> 00:05:49,839
twice twice double right so if I if my

132
00:05:47,839 --> 00:05:53,819
digit is one and I add it to a one

133
00:05:49,819 --> 00:05:55,360
what's the most it can become a - I

134
00:05:53,360 --> 00:05:59,038
can't do any worse than doubling

135
00:05:55,038 --> 00:06:03,418
something right that's it if I double

136
00:05:59,418 --> 00:06:07,379
something I need one more bit by adding

137
00:06:03,379 --> 00:06:10,158
right all ones to all ones the most I'm

138
00:06:07,158 --> 00:06:11,490
gonna need is one more bit and that's

139
00:06:10,490 --> 00:06:17,718
the worst case right the biggest number

140
00:06:11,718 --> 00:06:19,769
I can have in n bits is n ones right I

141
00:06:17,769 --> 00:06:25,940
have a 4-bit number the biggest number I

142
00:06:19,940 --> 00:06:26,009
can have is one one one one if I add

143
00:06:25,009 --> 00:06:28,658
that number to itself it's one plus one

144
00:06:26,658 --> 00:06:30,370
I doubled that fit one plus one I

145
00:06:28,370 --> 00:06:31,019
doubled that bit one plus one I doubled

146
00:06:30,019 --> 00:06:34,579
that bit one plus one I doubled that bit

147
00:06:31,579 --> 00:06:35,279
one plus one I doubled that bit if I

148
00:06:34,279 --> 00:06:38,769
double all the bits I double the number

149
00:06:35,769 --> 00:06:41,180
all I need is one more bits for twice

150
00:06:38,180 --> 00:06:45,718
one more bid for twice as big one two

151
00:06:41,718 --> 00:06:48,430
four eight the next bits gonna be 16

152
00:06:45,430 --> 00:06:52,529
does that make sense now that doesn't

153
00:06:48,529 --> 00:06:52,870
mean I necessarily need an extra bit

154
00:06:52,870 --> 00:07:03,639
right if I have a 4-bit number and I

155
00:06:55,639 --> 00:07:05,079
have you know 1 1 0 0 1 1 0 0 I can add

156
00:07:03,079 --> 00:07:07,690
a 1 and I don't need any more bits I can

157
00:07:05,690 --> 00:07:08,038
add it 1-0 and I don't need any more

158
00:07:07,038 --> 00:07:13,990
bits I can add a 1 1 I don't need any

159
00:07:08,990 --> 00:07:14,038
more bits I only need more bits if I'm

160
00:07:13,038 --> 00:07:17,718
trying to add something that has a 1 in

161
00:07:14,718 --> 00:07:24,949
the first the high order two bits

162
00:07:17,949 --> 00:07:27,189
make sense okay so that's all this slide

163
00:07:24,189 --> 00:07:29,360
here is trying to tell us if I had two

164
00:07:27,360 --> 00:07:34,560
you know two numbers are the same with

165
00:07:29,560 --> 00:07:37,089
the most I need is one extra bit okay

166
00:07:34,089 --> 00:07:42,569
now if I add two 32-bit numbers but most

167
00:07:37,569 --> 00:07:45,180
i need is a 33 bit number unfortunately

168
00:07:42,180 --> 00:07:48,360
right that's not how the world works

169
00:07:45,360 --> 00:07:50,038
right if I have if I have some size for

170
00:07:48,038 --> 00:07:51,139
my data type and it's 32 bits and I need

171
00:07:50,139 --> 00:07:54,908
a 33 bit number I've lost that

172
00:07:51,908 --> 00:07:57,728
high-order bit the way this works is

173
00:07:54,728 --> 00:07:59,149
like modular arithmetic it wraps around

174
00:07:57,149 --> 00:08:01,649
okay so I lose the high-order bit and

175
00:07:59,649 --> 00:08:06,990
keep the low-order bits the high-order

176
00:08:01,990 --> 00:08:11,310
bit it's called carry out just gets

177
00:08:06,310 --> 00:08:12,079
dropped okay so it's modulus arithmetic

178
00:08:11,079 --> 00:08:16,329
it's like we go around the clock and

179
00:08:12,329 --> 00:08:17,658
then we get too high right we lose the

180
00:08:16,658 --> 00:08:20,740
number of times we went around that

181
00:08:17,740 --> 00:08:27,709
clock right and we keep wherever the you

182
00:08:20,709 --> 00:08:28,098
know the hand hex happens to be okay so

183
00:08:27,098 --> 00:08:31,319
that's how it works it just wraps around

184
00:08:28,319 --> 00:08:32,180
now as it turns out when it comes to

185
00:08:31,180 --> 00:08:34,649
mathematical operations we have a carry

186
00:08:32,649 --> 00:08:36,269
out like this we'll learn a little later

187
00:08:34,269 --> 00:08:38,820
that gets stored in a flag so in this

188
00:08:36,820 --> 00:08:41,529
particular case we can actually sort of

189
00:08:38,529 --> 00:08:42,110
figure it out if we try we can see that

190
00:08:41,110 --> 00:08:44,668
our result is whatever our result

191
00:08:42,668 --> 00:08:46,049
happens to be and then we can go back

192
00:08:44,049 --> 00:08:55,059
and look and see that carry flag is on

193
00:08:46,059 --> 00:08:55,200
or not okay

194
00:08:56,200 --> 00:09:02,049
so what is this well I have my two

195
00:09:00,049 --> 00:09:04,750
numbers you being one number WV being

196
00:09:02,750 --> 00:09:08,730
another number right and so this shows

197
00:09:04,730 --> 00:09:09,000
you being 0 1 2 3 4 5 6 7 8 9 10 11 12

198
00:09:08,000 --> 00:09:13,139
13 14 right

199
00:09:09,139 --> 00:09:18,009
and this shows thee and so if we hold V

200
00:09:13,009 --> 00:09:21,110
constant for a moment at 0 we can just

201
00:09:18,110 --> 00:09:26,289
see this plot that shows you with every

202
00:09:21,289 --> 00:09:31,200
value from 0 to 15 that makes sense

203
00:09:26,200 --> 00:09:38,460
unsurprisingly 0 1 2 3 4 5 6

204
00:09:31,460 --> 00:09:42,509
it goes up monotonically right now if I

205
00:09:38,509 --> 00:09:44,350
say that instead of being 0 V is 1 well

206
00:09:42,350 --> 00:09:46,269
what happens well

207
00:09:44,269 --> 00:09:52,399
I start out a little higher I'm now

208
00:09:46,399 --> 00:09:54,490
starting out at 1 instead of 0 right but

209
00:09:52,490 --> 00:10:00,110
I finish up in the same place basically

210
00:09:54,110 --> 00:10:04,880
right ok

211
00:10:00,880 --> 00:10:06,149
and so basically what we see is given

212
00:10:04,149 --> 00:10:16,789
any combination of U and V I can't get

213
00:10:06,789 --> 00:10:16,490
above in this case 15 make sense okay

214
00:10:17,490 --> 00:10:22,049
and then so that forms a nice planar

215
00:10:20,049 --> 00:10:22,610
surface

216
00:10:27,610 --> 00:10:34,110
all right now what happens if I add two

217
00:10:32,110 --> 00:10:38,330
numbers you know that get me past that

218
00:10:34,330 --> 00:10:39,500
you're the size of my data type well we

219
00:10:38,500 --> 00:10:42,970
see the nice planar surface when you saw

220
00:10:39,970 --> 00:10:44,429
in the prior slide but now what happens

221
00:10:42,429 --> 00:10:49,799
is if we go one past we go from one one

222
00:10:44,799 --> 00:10:52,259
one one right to zero zero zero zero

223
00:10:49,259 --> 00:10:58,269
once we go one pass we crash down to

224
00:10:52,269 --> 00:11:01,029
zero zero zero zero zero and that's what

225
00:10:58,029 --> 00:11:03,720
that line shows when the sum of U plus V

226
00:11:01,720 --> 00:11:08,850
right turns out to be one more than we

227
00:11:03,850 --> 00:11:12,669
can store then what happens right then

228
00:11:08,669 --> 00:11:14,370
it's zero and from that point we just

229
00:11:12,370 --> 00:11:16,799
start growing again if we the sum of U

230
00:11:14,799 --> 00:11:18,690
and V is one more than the point where

231
00:11:16,690 --> 00:11:22,220
it becomes zero well it's one more than

232
00:11:18,220 --> 00:11:26,330
all zeros it's one and that's what that

233
00:11:22,330 --> 00:11:30,950
line is and so on so we form a second

234
00:11:26,950 --> 00:11:38,929
plane if we keep going right we can't

235
00:11:30,929 --> 00:11:38,309
why can't we have a third plane yeah

236
00:11:38,309 --> 00:11:42,990
yeah so we said right if you add two

237
00:11:40,990 --> 00:11:47,009
things together they can't be worse than

238
00:11:42,009 --> 00:11:50,350
double right and so here's the single

239
00:11:47,350 --> 00:11:52,470
there's the double you can't get a third

240
00:11:50,470 --> 00:11:55,539
plane out of that because if I add two

241
00:11:52,539 --> 00:11:59,210
numbers at worst case they're double

242
00:11:55,210 --> 00:12:05,429
what they were before make sense

243
00:11:59,429 --> 00:12:05,130
everybody seen this view on it all right

244
00:12:07,130 --> 00:12:11,690
two's complement addition well two's

245
00:12:09,690 --> 00:12:17,870
complement addition is exactly the same

246
00:12:11,870 --> 00:12:20,130
right as normal addition we showed this

247
00:12:17,130 --> 00:12:21,279
right we took a regular number right and

248
00:12:20,279 --> 00:12:24,899
added it to a two's complement number

249
00:12:21,899 --> 00:12:26,509
and got zero using a regular adder and

250
00:12:24,509 --> 00:12:29,759
then we showed that if we added one to

251
00:12:26,759 --> 00:12:31,399
that right whether we added that one to

252
00:12:29,399 --> 00:12:32,049
the two the two's complement number

253
00:12:31,049 --> 00:12:35,610
added that one to the other number right

254
00:12:32,610 --> 00:12:37,490
it grew by one and so on that's the

255
00:12:35,490 --> 00:12:40,320
beauty of this is it allows us to do

256
00:12:37,320 --> 00:12:45,620
addition and subtraction with just an

257
00:12:40,620 --> 00:12:47,600
adder right the way math works is

258
00:12:45,600 --> 00:12:49,460
exactly the same it's just the way that

259
00:12:47,460 --> 00:12:51,710
we interpret the numbers that changes

260
00:12:49,710 --> 00:12:54,870
the bits are the same they're still bits

261
00:12:51,870 --> 00:12:56,659
in a number the operation the adder is

262
00:12:54,659 --> 00:13:00,730
still the same it's still adding 1 and 1

263
00:12:56,730 --> 00:13:08,089
to get 0 and carry a 1 we're warning 0

264
00:13:00,089 --> 00:13:13,720
to 1 ok so there's really no difference

265
00:13:08,720 --> 00:13:16,620
alright how we interpret things however

266
00:13:13,620 --> 00:13:16,149
might be slightly different

267
00:13:17,149 --> 00:13:23,139
oK we've been through that before let's

268
00:13:19,139 --> 00:13:24,009
get to the picture now you see in effect

269
00:13:23,009 --> 00:13:27,630
we have the same two planes we had

270
00:13:24,630 --> 00:13:31,480
before we have one plane here and one

271
00:13:27,480 --> 00:13:36,049
plane here to see that we've got to pick

272
00:13:31,049 --> 00:13:38,720
this piece up and move it over here not

273
00:13:36,720 --> 00:13:40,669
surprising right because it's the same

274
00:13:38,669 --> 00:13:43,350
math we had before we're just

275
00:13:40,350 --> 00:13:47,500
interpreting it differently it's the

276
00:13:43,500 --> 00:13:49,429
same bits added by the same adder we're

277
00:13:47,429 --> 00:13:54,409
just choosing to renumber the number

278
00:13:49,409 --> 00:13:58,659
line ok to change where 0 is which

279
00:13:54,659 --> 00:14:01,649
shifts where these planes are do you see

280
00:13:58,649 --> 00:14:03,380
that it's still the same number line

281
00:14:01,380 --> 00:14:05,690
right if you go back to third grade or

282
00:14:03,690 --> 00:14:06,190
first grade and have that number line

283
00:14:05,190 --> 00:14:09,929
you used to learn adding it's still the

284
00:14:06,929 --> 00:14:14,179
same number line with the same line line

285
00:14:09,179 --> 00:14:16,639
line line line line line line ok if you

286
00:14:14,639 --> 00:14:18,860
add 4 you're still moving forward by 4

287
00:14:16,860 --> 00:14:18,509
if you add 2 you're still moving forward

288
00:14:18,509 --> 00:14:22,899
by

289
00:14:18,899 --> 00:14:24,350
- okay in this case if you get to the

290
00:14:22,350 --> 00:14:28,830
end you just loop back to the beginning

291
00:14:24,830 --> 00:14:31,769
it works just the same and it works just

292
00:14:28,769 --> 00:14:33,130
the same as your first grade number line

293
00:14:31,130 --> 00:14:36,179
whether you're using two's complement

294
00:14:33,179 --> 00:14:38,870
numbers or regular numbers the only

295
00:14:36,870 --> 00:14:52,880
difference is what labels we put on

296
00:14:38,880 --> 00:14:58,200
those points so what happens when you

297
00:14:52,200 --> 00:14:59,080
add negative 1 to negative 1 so right so

298
00:14:58,080 --> 00:15:02,909
if I add negative 1 to negative 1 I have

299
00:14:59,909 --> 00:15:05,820
a carry out situation right and you know

300
00:15:02,820 --> 00:15:07,399
really the problem there is if you look

301
00:15:05,399 --> 00:15:10,679
at the number line what you find is that

302
00:15:07,679 --> 00:15:11,230
there is we like to think of it as

303
00:15:10,230 --> 00:15:14,759
positive numbers and negative numbers

304
00:15:11,759 --> 00:15:15,250
but the reality of the situation is that

305
00:15:14,250 --> 00:15:19,630
there are negative numbers and

306
00:15:15,630 --> 00:15:21,139
non-negative numbers and 0 is a non

307
00:15:19,139 --> 00:15:24,450
negative number which comes out of the

308
00:15:21,450 --> 00:15:26,809
non negative side of the number line the

309
00:15:24,809 --> 00:15:28,820
result of that is that we do have one

310
00:15:26,820 --> 00:15:30,830
more on the negative side than we do on

311
00:15:28,830 --> 00:15:32,720
the non negative side so our most

312
00:15:30,720 --> 00:15:34,610
negative number is not balanced by is

313
00:15:32,610 --> 00:15:37,110
not equal to the most positive number

314
00:15:34,110 --> 00:15:40,259
it's one less and so you know how do I

315
00:15:37,259 --> 00:15:41,440
explain that it's an edge case but

316
00:15:40,440 --> 00:15:43,490
that's the reason that there's the edge

317
00:15:41,490 --> 00:15:50,769
case it's not some random math is broken

318
00:15:43,769 --> 00:15:52,809
it's we have this artifact okay and so

319
00:15:50,809 --> 00:15:54,409
there you have it

320
00:15:52,409 --> 00:15:57,419
right the same two planes we had before

321
00:15:54,419 --> 00:15:59,830
but they're slightly different right in

322
00:15:57,830 --> 00:16:06,909
that this starts out with the most

323
00:15:59,909 --> 00:16:08,028
negative number right this ends with the

324
00:16:06,028 --> 00:16:10,789
most positive number if you add the two

325
00:16:08,789 --> 00:16:14,740
most negative numbers together you're

326
00:16:10,740 --> 00:16:15,820
obviously not going to get 0 we're two

327
00:16:14,820 --> 00:16:23,958
very negative numbers together you're

328
00:16:15,958 --> 00:16:24,009
not going to get 0 right ok and you were

329
00:16:23,009 --> 00:16:26,059
talking before you're talking about the

330
00:16:24,059 --> 00:16:28,399
case of of the of the value 1 in all

331
00:16:26,399 --> 00:16:28,279
zeroes right

332
00:16:29,279 --> 00:16:34,438
who-who's question was that you were

333
00:16:31,438 --> 00:16:36,889
asking about one or all zeros right or

334
00:16:34,889 --> 00:16:40,839
ones okay all ones not one I'm sorry

335
00:16:36,839 --> 00:16:41,049
so all ones up well what were you

336
00:16:40,049 --> 00:16:42,429
talking about I was confused actually

337
00:16:41,429 --> 00:16:49,240
another thing about your question I'm

338
00:16:42,240 --> 00:16:59,230
actually slightly confused okay so if I

339
00:16:49,230 --> 00:17:00,370
do negative one and negative one right

340
00:16:59,370 --> 00:17:03,839
so if I add all ones and all ones what

341
00:17:00,839 --> 00:17:09,269
do I end up with the bit pattern for for

342
00:17:03,269 --> 00:17:12,679
negative ones what Oh once okay and so

343
00:17:09,679 --> 00:17:14,088
if I add if I add all ones I'm sorry I

344
00:17:12,088 --> 00:17:16,400
misinterpreted your question so if I add

345
00:17:14,400 --> 00:17:35,380
if I add all one stall ones what am I

346
00:17:16,380 --> 00:17:37,429
actually gonna get go ahead are you

347
00:17:35,429 --> 00:17:38,740
happy yeah you sure yeah okay I thought

348
00:17:37,740 --> 00:17:41,640
you'd ask me the question we the

349
00:17:38,640 --> 00:17:42,308
high-order bit was up where was with the

350
00:17:41,308 --> 00:17:49,240
I thought you're asking different

351
00:17:42,240 --> 00:17:51,380
questions I apologize so the the problem

352
00:17:49,380 --> 00:17:56,240
the the problem the problem is that T is

353
00:17:51,240 --> 00:17:58,210
the T min plus t max doesn't equal zero

354
00:17:56,210 --> 00:17:59,470
okay that's where the system we have

355
00:17:58,470 --> 00:18:02,970
breaks down a little bit B is the number

356
00:17:59,970 --> 00:18:05,279
one isn't symmetric and so if you take

357
00:18:02,279 --> 00:18:10,759
the absolute value of T min you end up

358
00:18:05,759 --> 00:18:12,558
with a slight mess does that make sense

359
00:18:10,558 --> 00:18:13,419
that's where that's where the system

360
00:18:12,419 --> 00:18:26,829
breaks down but you're okay with

361
00:18:13,829 --> 00:18:26,349
negative 1 plus negative 1 yeah okay

362
00:18:28,349 --> 00:18:33,170
so if I have the most if we forget about

363
00:18:32,170 --> 00:18:35,400
the symbols for a moment I take the

364
00:18:33,400 --> 00:18:36,259
biggest negative number the negative

365
00:18:35,259 --> 00:18:39,430
number I have with the greatest

366
00:18:36,430 --> 00:18:40,460
magnitude and I add it to the positive

367
00:18:39,460 --> 00:18:43,390
number I have with the greatest

368
00:18:40,390 --> 00:18:47,119
magnitude the result is not going to be

369
00:18:43,119 --> 00:18:50,769
zero what's that

370
00:18:47,769 --> 00:18:53,769
yes it's gonna be minus one does that

371
00:18:50,769 --> 00:18:57,140
make sense so it's not the case if I

372
00:18:53,140 --> 00:18:58,609
take the absolute value of T min then

373
00:18:57,609 --> 00:19:00,720
I'm gonna get what I think I'm gonna get

374
00:18:58,720 --> 00:19:03,700
because there is no absolute value of T

375
00:19:00,700 --> 00:19:05,660
men that make sense

376
00:19:03,660 --> 00:19:09,710
there's just no there's we don't have

377
00:19:05,710 --> 00:19:11,339
that point on our number line okay so

378
00:19:09,339 --> 00:19:13,500
back to this so this shows basically the

379
00:19:11,500 --> 00:19:15,839
same two planes we had before but our

380
00:19:13,839 --> 00:19:17,279
number line has now been remembered

381
00:19:15,279 --> 00:19:20,049
instead of our number line you know

382
00:19:17,049 --> 00:19:24,920
going from going from zero here right on

383
00:19:20,920 --> 00:19:28,819
up right it's starting here at negatives

384
00:19:24,819 --> 00:19:30,359
and so it's just been shifted but the

385
00:19:28,359 --> 00:19:32,099
basic thing is it's still the same we

386
00:19:30,099 --> 00:19:34,319
still keep adding right until the point

387
00:19:32,319 --> 00:19:36,150
where all of our bits become one and we

388
00:19:34,150 --> 00:19:38,519
add one and it rotates back to zero it

389
00:19:36,519 --> 00:19:41,619
doesn't matter that's now happening from

390
00:19:38,619 --> 00:19:42,680
a negative number versus from a positive

391
00:19:41,680 --> 00:19:47,369
number right

392
00:19:42,369 --> 00:19:48,230
I can under flow just as well as I can

393
00:19:47,230 --> 00:19:51,759
under overflow and that's always the

394
00:19:48,759 --> 00:19:53,220
case if you take if you take zero and

395
00:19:51,220 --> 00:19:56,589
subtract one right you're gonna end up

396
00:19:53,589 --> 00:20:00,890
wrapping forward to a big number so this

397
00:19:56,890 --> 00:20:03,579
is nothing more than a renumber align it

398
00:20:00,579 --> 00:20:05,279
doesn't change the math the planes are

399
00:20:03,279 --> 00:20:09,380
still the same we've just moved them by

400
00:20:05,380 --> 00:20:09,450
starting zero somewhere different yes

401
00:20:14,450 --> 00:20:21,400
okay go ahead

402
00:20:16,400 --> 00:20:27,450
actually you actually get all the ones

403
00:20:21,450 --> 00:20:42,210
carryover it still ends up being like

404
00:20:27,210 --> 00:20:44,808
just do it but you do get so rebase his

405
00:20:42,808 --> 00:20:45,609
answer was basically says was if you

406
00:20:44,609 --> 00:20:47,869
concerned about negative 1 plus negative

407
00:20:45,869 --> 00:20:48,400
1 do it yeah

408
00:20:47,400 --> 00:20:50,990
actually write it out on your paper

409
00:20:48,990 --> 00:20:52,548
right now and you'll see that it

410
00:20:50,548 --> 00:20:54,440
actually works if you're concerned about

411
00:20:52,440 --> 00:20:55,419
negative team min and team in not being

412
00:20:54,419 --> 00:21:11,710
balanced you're correct and they're

413
00:20:55,710 --> 00:21:13,369
simply not yes see it again so okay so

414
00:21:11,369 --> 00:21:15,589
the question is if we have a bit pattern

415
00:21:13,589 --> 00:21:21,029
with T min what does that bit pattern

416
00:21:15,029 --> 00:21:24,538
look like what is the bit pattern 14 min

417
00:21:21,538 --> 00:21:27,839
that's all I care about right now 1

418
00:21:24,839 --> 00:21:30,450
followed by all zeros that one is in the

419
00:21:27,450 --> 00:21:33,298
highest order position right so if I

420
00:21:30,298 --> 00:21:35,179
take ones in the highest order position

421
00:21:33,179 --> 00:21:40,429
and I add them together that position

422
00:21:35,429 --> 00:21:45,950
becomes what 1 plus 1 becomes 0 and that

423
00:21:40,950 --> 00:21:50,509
one gets carried out right because 1 + 1

424
00:21:45,509 --> 00:21:53,429
is 2 right 0 in the current place and 1

425
00:21:50,429 --> 00:21:57,130
in the next place over does that make

426
00:21:53,130 --> 00:21:59,119
sense so if I have a bit my 1 + 1 or the

427
00:21:57,119 --> 00:22:01,880
highest bit that bit becomes 0 carry the

428
00:21:59,880 --> 00:22:04,798
1 and there's nothing there to carry it

429
00:22:01,798 --> 00:22:06,829
to so I just have all zeros does that

430
00:22:04,829 --> 00:22:10,679
make sense

431
00:22:06,679 --> 00:22:10,308
does that answer your question

432
00:22:10,308 --> 00:22:14,558
that was a very tentative yes

433
00:22:26,558 --> 00:22:37,909
see Europe set their brakes the Europe

434
00:22:31,909 --> 00:22:39,308
said there could break well so what I

435
00:22:37,308 --> 00:22:41,440
can tell you is that is the behavior and

436
00:22:39,440 --> 00:22:43,148
the question is is that behavior

437
00:22:41,148 --> 00:22:45,028
intuitive to people the answer is no

438
00:22:43,028 --> 00:22:46,349
which brings us back to the discussion

439
00:22:45,349 --> 00:22:49,669
we had the thirty first day of class

440
00:22:46,669 --> 00:22:52,599
which is why 213 is a critical class

441
00:22:49,599 --> 00:22:54,220
because in our everyday lives as

442
00:22:52,220 --> 00:22:55,529
programmers we forget these things and

443
00:22:54,529 --> 00:22:59,970
we write a lot of software that assumes

444
00:22:55,970 --> 00:23:01,108
that an INT is an integer and then

445
00:22:59,108 --> 00:23:05,690
sometimes we get these edge cases and

446
00:23:01,690 --> 00:23:08,929
they matter right and if we're writing

447
00:23:05,929 --> 00:23:10,239
software that can tolerate some failure

448
00:23:08,239 --> 00:23:11,128
maybe we discover this in advance and

449
00:23:10,128 --> 00:23:14,509
then we have to go back and fix a bug

450
00:23:11,509 --> 00:23:16,538
not the best of all worlds if writing

451
00:23:14,538 --> 00:23:18,700
isn't mission critical software we're

452
00:23:16,700 --> 00:23:20,470
mission critical is you know you allow

453
00:23:18,470 --> 00:23:21,210
that you apply your your definition

454
00:23:20,210 --> 00:23:24,858
there but we're we can't tolerate bugs

455
00:23:21,858 --> 00:23:25,739
which is a lot of software really you

456
00:23:24,739 --> 00:23:28,849
have to think of these things in advance

457
00:23:25,849 --> 00:23:30,700
right and ensure that your data is in

458
00:23:28,700 --> 00:23:34,409
proper ranges that your data is properly

459
00:23:30,409 --> 00:23:35,099
normalized or that you use a library an

460
00:23:34,099 --> 00:23:37,868
arbitrary precision arithmetic library

461
00:23:35,868 --> 00:23:39,759
that can stack integers together to give

462
00:23:37,759 --> 00:23:42,970
you a bigger one

463
00:23:39,970 --> 00:23:45,460
obviously in software not in hardware

464
00:23:42,460 --> 00:23:56,679
does that address your question okay I

465
00:23:45,679 --> 00:23:59,200
saw some other hands popping up yes so

466
00:23:56,200 --> 00:24:01,298
right so this is the question is where

467
00:23:59,298 --> 00:24:04,128
does this system originate okay well

468
00:24:01,128 --> 00:24:06,190
first of all this class is x86 based and

469
00:24:04,190 --> 00:24:09,230
this is the system used by the x86

470
00:24:06,230 --> 00:24:11,888
family of processors okay secondly for

471
00:24:09,888 --> 00:24:14,720
historical reasons this is the system

472
00:24:11,720 --> 00:24:21,210
used by any general-purpose processor on

473
00:24:14,210 --> 00:24:23,138
earth at this point the reason signed

474
00:24:21,138 --> 00:24:27,868
over fluency is undefined is because the

475
00:24:23,868 --> 00:24:30,349
the the inventors and standard keepers

476
00:24:27,349 --> 00:24:32,259
for C do not want to impose a standard

477
00:24:30,259 --> 00:24:33,329
in the language that is not necessarily

478
00:24:32,329 --> 00:24:36,710
going to be supported by the underlying

479
00:24:33,710 --> 00:24:37,888
architecture and they're confident that

480
00:24:36,888 --> 00:24:38,069
the

481
00:24:37,069 --> 00:24:40,720
underlying architecture will be able to

482
00:24:38,720 --> 00:24:41,429
add stuff in the middle they're not

483
00:24:40,429 --> 00:24:44,839
confident about what the underlying

484
00:24:41,839 --> 00:24:48,028
architecture might do when the

485
00:24:44,028 --> 00:24:50,440
representation breaks down and so if

486
00:24:48,440 --> 00:24:51,179
they would have said see must work this

487
00:24:50,179 --> 00:24:53,740
way and then somebody would have

488
00:24:51,740 --> 00:24:55,028
invented a simpler processor for a

489
00:24:53,028 --> 00:24:57,730
simpler application right we're simple

490
00:24:55,730 --> 00:24:58,589
was the rule day now math gets really

491
00:24:57,589 --> 00:25:02,909
complicated if they want to try to use C

492
00:24:58,909 --> 00:25:05,329
on so that's why the folks who design C

493
00:25:02,329 --> 00:25:06,058
basically said you know here's the

494
00:25:05,058 --> 00:25:08,710
number line you good as long as you stay

495
00:25:06,710 --> 00:25:09,179
on the number line if you cross this

496
00:25:08,179 --> 00:25:10,589
edge across this edge

497
00:25:09,589 --> 00:25:12,759
you better know what's going on

498
00:25:10,759 --> 00:25:14,710
underneath because we're giving you no

499
00:25:12,710 --> 00:25:16,628
promises the architecture may give you

500
00:25:14,628 --> 00:25:19,398
promises the compiler writer may give

501
00:25:16,398 --> 00:25:21,308
you promises right good or bad luck may

502
00:25:19,308 --> 00:25:23,710
give you something but we as the C

503
00:25:21,710 --> 00:25:26,329
language are gonna are not gonna give

504
00:25:23,329 --> 00:25:28,210
you an answer to that question I saw

505
00:25:26,210 --> 00:25:39,909
some other hands somewhere here

506
00:25:28,909 --> 00:25:43,140
somewhere anywhere nope okay

507
00:25:39,140 --> 00:25:50,490
ah there are a lot of words on that

508
00:25:43,490 --> 00:25:54,900
slide some of them are boldface I see

509
00:25:50,900 --> 00:25:59,740
time signs it's always bad even worse

510
00:25:54,740 --> 00:26:02,420
they're they're like exponents lease

511
00:25:59,420 --> 00:26:04,240
there are no subscripts I really hate

512
00:26:02,240 --> 00:26:12,990
what I have exponents add subscripts

513
00:26:04,990 --> 00:26:13,679
there's one oh shit oh no oh no just

514
00:26:12,679 --> 00:26:17,029
kidding

515
00:26:13,029 --> 00:26:19,089
alright so now let's talk about

516
00:26:17,089 --> 00:26:21,880
multiplication multiplication is

517
00:26:19,880 --> 00:26:23,380
obviously more complicated than like

518
00:26:21,380 --> 00:26:24,058
addition right you learn addition and

519
00:26:23,058 --> 00:26:24,048
subtraction in kindergarten and

520
00:26:24,048 --> 00:26:28,859
first-grade didn't get the

521
00:26:24,859 --> 00:26:30,119
multiplication till second or third okay

522
00:26:28,119 --> 00:26:32,650
so let me ask you this we said that if I

523
00:26:30,650 --> 00:26:35,839
add two numbers together the worst case

524
00:26:32,839 --> 00:26:38,630
that the number is doubled what if I

525
00:26:35,630 --> 00:26:40,660
multiply two numbers together let's

526
00:26:38,660 --> 00:26:47,669
imagine we multiply two two bit numbers

527
00:26:40,669 --> 00:26:51,720
together how big could my result be well

528
00:26:47,720 --> 00:26:51,019
what's the biggest two-bit number

529
00:26:53,019 --> 00:26:59,240
what's the bit pattern for the biggest

530
00:26:55,240 --> 00:27:07,710
two-bit number one one one one

531
00:26:59,710 --> 00:27:08,808
represents what decimal number I waiting

532
00:27:07,808 --> 00:27:10,890
for somebody say that so we're playing

533
00:27:08,890 --> 00:27:14,390
with unsigned numbers it represents the

534
00:27:10,390 --> 00:27:15,109
rate otherwise negative one okay

535
00:27:14,109 --> 00:27:17,190
so let's assume we're dealing with out

536
00:27:15,190 --> 00:27:19,259
in sign for the moment so the the worst

537
00:27:17,259 --> 00:27:20,420
case four integer multiplication is

538
00:27:19,420 --> 00:27:22,859
going to be for two bit into

539
00:27:20,859 --> 00:27:28,240
multiplications three times three which

540
00:27:22,240 --> 00:27:30,599
is what nine we agree if I need to

541
00:27:28,599 --> 00:27:37,220
represent nine in binary how many digits

542
00:27:30,220 --> 00:27:40,200
does it take me four right 1 2 4 right 4

543
00:27:37,200 --> 00:27:46,210
plus 2 is 6 plus 1 is 7 not there right

544
00:27:40,210 --> 00:27:48,480
1 2 4 8 right so we have an 8 plus no 4

545
00:27:46,480 --> 00:27:51,910
is plus no 2's plus a 1 okay

546
00:27:48,910 --> 00:27:55,670
now let's play with a 3 bit number if I

547
00:27:51,670 --> 00:28:00,089
have a 3 bit unsigned number what's the

548
00:27:55,089 --> 00:28:03,279
biggest number I can represent 7 4 plus

549
00:28:00,279 --> 00:28:09,039
2 plus 1 if I multiply 7 & 7 what do I

550
00:28:03,039 --> 00:28:14,929
get if I multiply 7 & 7 what do I get

551
00:28:09,929 --> 00:28:14,880
49 how many bits is take to represent 49

552
00:28:17,880 --> 00:28:30,240
1 2 4 8 16 right how many bits to the

553
00:28:25,240 --> 00:28:33,940
take so if I do 1 2 4 8 16 that's 5 bits

554
00:28:30,940 --> 00:28:36,160
that gives me 231 how many bits do I

555
00:28:33,160 --> 00:28:39,880
need 6 okay so I started out with 2 3

556
00:28:36,880 --> 00:28:41,099
but with 2 / 3 bit numbers I needed a

557
00:28:39,099 --> 00:28:43,049
6-bit I needed up to 6 bits for the

558
00:28:41,049 --> 00:28:45,690
result I had to I had booked about 2 2

559
00:28:43,690 --> 00:28:51,250
bit numbers I needed how many bits for

560
00:28:45,250 --> 00:28:53,400
the result how many 4 ok let's try it

561
00:28:51,400 --> 00:28:59,500
one more time let's say we have a 4-bit

562
00:28:53,500 --> 00:28:59,599
number 1 1 1 1 what does that represent

563
00:28:59,599 --> 00:29:06,669
fifteen okay if I multiplied 15 and 15

564
00:29:04,669 --> 00:29:11,009
what do I get

565
00:29:06,009 --> 00:29:14,859
what's that two twenty-five

566
00:29:11,859 --> 00:29:24,029
okay how many bits does it take to

567
00:29:14,029 --> 00:29:29,950
represent 225 1 2 4 8 16 32 64 128 right

568
00:29:24,950 --> 00:29:33,390
so 128 gets me to 255 right how many

569
00:29:29,390 --> 00:29:39,650
bits does it take what's that

570
00:29:33,650 --> 00:29:42,349
1 2 4 8 16 32 64 128 that gets me to 255

571
00:29:39,349 --> 00:29:48,589
right so I multiply 2 4 bit numbers how

572
00:29:42,589 --> 00:29:52,529
many bits did I need a ok so what seems

573
00:29:48,529 --> 00:29:55,359
like the general rule here twice as many

574
00:29:52,359 --> 00:29:56,220
why now give me the intuition beyond

575
00:29:55,220 --> 00:30:05,269
that now we've gone through and play the

576
00:29:56,269 --> 00:30:05,368
game yeah

577
00:30:11,368 --> 00:30:19,259
to the N times 2 to the N is 2 to the 2n

578
00:30:16,259 --> 00:30:19,210
is that what you're suggesting

579
00:30:21,210 --> 00:30:26,999
ok ok so I think you're exactly right so

580
00:30:24,999 --> 00:30:27,618
if you wanna take this as a mathematic

581
00:30:26,618 --> 00:30:29,730
you're exactly right

582
00:30:27,730 --> 00:30:32,769
tuning it you know 2 to the N times to

583
00:30:29,769 --> 00:30:34,769
the N is equal to 2 to the 2n right and

584
00:30:32,769 --> 00:30:37,720
that's twice as many bits because each

585
00:30:34,720 --> 00:30:38,148
bit represents a power of 2 beautiful

586
00:30:37,148 --> 00:30:39,440
that's actually an excellent way of

587
00:30:38,440 --> 00:30:42,339
thinking about it if you happen to be a

588
00:30:39,339 --> 00:30:43,308
mathematician any mathematician can

589
00:30:42,308 --> 00:30:47,210
leave the room for the rest of the

590
00:30:43,210 --> 00:30:49,888
explanation and so for those who aren't

591
00:30:47,888 --> 00:30:50,089
mathematical and they're thinking and

592
00:30:49,089 --> 00:30:52,169
that is an excellent way of thinking

593
00:30:50,169 --> 00:30:59,558
about it right what intuition do we have

594
00:30:52,558 --> 00:30:59,980
yeah we're shifting them

595
00:31:09,980 --> 00:31:16,960
maybe that I think that may complicate

596
00:31:12,960 --> 00:31:17,289
some things to think of it that way so

597
00:31:16,289 --> 00:31:19,880
let's think about it in in when you were

598
00:31:17,880 --> 00:31:21,170
learning multiplication in second or

599
00:31:19,170 --> 00:31:23,750
third grade they told you that

600
00:31:21,750 --> 00:31:28,160
multiplication is repeated addition

601
00:31:23,160 --> 00:31:30,679
right then if I multiply four times two

602
00:31:28,679 --> 00:31:33,599
that's like adding two to itself four

603
00:31:30,599 --> 00:31:35,779
times by multiply three times five

604
00:31:33,779 --> 00:31:39,400
that's like adding three to itself five

605
00:31:35,400 --> 00:31:41,269
times and five to itself three times go

606
00:31:39,269 --> 00:31:41,160
ahead

607
00:31:53,160 --> 00:31:57,269
so I like your thinking I'm not sure the

608
00:31:55,269 --> 00:31:58,669
word amortized applies the suggestion

609
00:31:57,669 --> 00:32:02,869
was that it's like we added multiple

610
00:31:58,869 --> 00:32:02,319
times and each time can cause a carry

611
00:32:07,319 --> 00:32:12,308
but I know I'm gonna have it max with

612
00:32:09,308 --> 00:32:17,819
carries okay so think about it this way

613
00:32:12,819 --> 00:32:26,829
okay if I'm trying to multiply 2w bit

614
00:32:17,829 --> 00:32:28,259
numbers all right you know if I'm trying

615
00:32:26,259 --> 00:32:30,000
to multiply two W bit numbers to three

616
00:32:28,000 --> 00:32:33,369
bit numbers right we said how many extra

617
00:32:30,369 --> 00:32:34,339
bits would it take it can result in six

618
00:32:33,339 --> 00:32:38,869
if I have two 4 bit numbers how many

619
00:32:34,869 --> 00:32:42,798
bits would take a right to 5 bit numbers

620
00:32:38,798 --> 00:32:46,130
how many bits 10 right the reason for

621
00:32:42,130 --> 00:32:48,538
this what's that the reason for this is

622
00:32:46,538 --> 00:32:49,339
that if every time I'm doing one of

623
00:32:48,339 --> 00:32:54,659
those ads right

624
00:32:49,659 --> 00:32:56,400
I could need one more bit and I have to

625
00:32:54,400 --> 00:32:59,288
do that up to that many times of ads I

626
00:32:56,288 --> 00:33:00,079
could need that many more bits right

627
00:32:59,079 --> 00:33:02,490
which brings us right back to your

628
00:33:00,490 --> 00:33:11,798
explanation which is that 2 to the N

629
00:33:02,798 --> 00:33:13,619
times 2 to the N is to the 2n okay so

630
00:33:11,619 --> 00:33:20,200
that's really where the slide is going

631
00:33:13,200 --> 00:33:22,409
okay so of course that's just as

632
00:33:20,409 --> 00:33:25,210
impossible as it was with addition right

633
00:33:22,210 --> 00:33:27,210
I have a fixed word size for my data

634
00:33:25,210 --> 00:33:30,990
type when I get to the edge of that

635
00:33:27,990 --> 00:33:33,579
right something is going to happen I'm

636
00:33:30,579 --> 00:33:37,308
gonna wrap around to 0 just like with

637
00:33:33,308 --> 00:33:40,029
addition it's modular arithmetic okay

638
00:33:37,029 --> 00:33:42,000
so with addition right I could wrap

639
00:33:40,000 --> 00:33:45,880
around at most once right my two

640
00:33:42,880 --> 00:33:48,250
positive numbers being added could

641
00:33:45,250 --> 00:33:50,220
result in a negative number what about

642
00:33:48,220 --> 00:33:52,048
with with multiplication how many times

643
00:33:50,048 --> 00:33:52,640
do I wrap around

644
00:34:01,640 --> 00:34:15,609
you're grabbing at it I can see it okay

645
00:34:07,609 --> 00:34:15,429
so let's take a look has that all right

646
00:34:18,429 --> 00:34:21,880
all right

647
00:34:19,880 --> 00:34:23,619
so unsigned multiplication see we have

648
00:34:21,619 --> 00:34:27,630
you times me the true product can be 2w

649
00:34:23,630 --> 00:34:29,559
time to W times the bits right so gonna

650
00:34:27,559 --> 00:34:31,420
be up to double right

651
00:34:29,420 --> 00:34:34,699
why if I have my full width size i could

652
00:34:31,699 --> 00:34:36,579
need another full width size okay and we

653
00:34:34,579 --> 00:34:40,469
saw that we took three six we said four

654
00:34:36,469 --> 00:34:42,250
eight right that's all that's saying

655
00:34:40,250 --> 00:34:45,019
right here the rest of these get

656
00:34:42,019 --> 00:34:47,949
discarded so we say discarded coming

657
00:34:45,949 --> 00:34:49,900
back to your question how many times

658
00:34:47,900 --> 00:34:52,750
could we end up going around the clock

659
00:34:49,750 --> 00:34:56,070
right that's captured by these numbers

660
00:34:52,070 --> 00:34:58,539
right that's why this is modular

661
00:34:56,539 --> 00:35:00,460
arithmetic we're throwing this away and

662
00:34:58,460 --> 00:35:05,590
just keep and we just keep will we land

663
00:35:00,590 --> 00:35:08,630
up all right so it ignores the high

664
00:35:05,630 --> 00:35:08,309
order bits

665
00:35:12,309 --> 00:35:15,650
okay now what about power of two

666
00:35:14,650 --> 00:35:18,780
multiplied

667
00:35:15,780 --> 00:35:20,820
okay we know that each bit position is

668
00:35:18,820 --> 00:35:23,079
worth double the bit position to its

669
00:35:20,079 --> 00:35:24,590
right we also know that each bit

670
00:35:23,590 --> 00:35:26,969
position is worth half the bit position

671
00:35:24,969 --> 00:35:29,909
to its left right those two go together

672
00:35:26,909 --> 00:35:32,380
so it is true that if I want to multiply

673
00:35:29,380 --> 00:35:35,369
something by two I can left shift it if

674
00:35:32,369 --> 00:35:37,199
I want to divide something by 2 I can

675
00:35:35,199 --> 00:35:40,630
write shift it and this works most of

676
00:35:37,630 --> 00:35:43,480
the time but it does get us into some

677
00:35:40,480 --> 00:35:46,239
weird situations for example if I write

678
00:35:43,239 --> 00:35:48,900
shift 2 divided by 2 what happens if it

679
00:35:46,900 --> 00:35:54,730
was not a number what happens if there

680
00:35:48,730 --> 00:35:58,699
was a 1 in that rightmost bit that one

681
00:35:54,699 --> 00:36:00,539
doesn't become a half right there's no

682
00:35:58,539 --> 00:36:03,730
half in an integer so it gets thrown

683
00:36:00,730 --> 00:36:07,489
away gets discarded in the word of the

684
00:36:03,489 --> 00:36:10,329
slide right so even numbers my right

685
00:36:07,329 --> 00:36:11,210
shift I'm gonna end up with 1/2 odd

686
00:36:10,210 --> 00:36:15,800
numbers my right shift we're gonna

687
00:36:11,800 --> 00:36:17,849
truncate that one to a zero what about

688
00:36:15,849 --> 00:36:20,739
what I left shift well that's gonna work

689
00:36:17,739 --> 00:36:21,409
well for a while but then I get to the

690
00:36:20,409 --> 00:36:25,670
point where I have a 1 in that leftmost

691
00:36:21,670 --> 00:36:28,090
bit right and when I write and my left

692
00:36:25,090 --> 00:36:33,210
shift it falls off the edge modular

693
00:36:28,210 --> 00:36:35,969
arithmetic ok now it is true that in a

694
00:36:33,969 --> 00:36:38,889
processor the left shift and right shift

695
00:36:35,889 --> 00:36:40,199
operations are faster than a multiply

696
00:36:38,199 --> 00:36:43,269
operation a multiply operation is

697
00:36:40,269 --> 00:36:46,750
relatively expensive a lot of logic that

698
00:36:43,750 --> 00:36:48,150
has to happen to do multiply right so

699
00:36:46,150 --> 00:36:51,880
some people who learn this tend to mess

700
00:36:48,880 --> 00:36:53,909
up their code and start converting any

701
00:36:51,909 --> 00:36:57,469
anything where they multiply by a power

702
00:36:53,469 --> 00:37:02,489
of two to a right or left shift don't do

703
00:36:57,489 --> 00:37:04,010
that right don't do that absolutely

704
00:37:02,010 --> 00:37:07,869
don't do that there are two reasons you

705
00:37:04,869 --> 00:37:08,539
should not do that the first reason is

706
00:37:07,539 --> 00:37:11,980
that anybody who has to read your code

707
00:37:08,980 --> 00:37:14,079
is gonna have trouble when you left

708
00:37:11,079 --> 00:37:15,380
shift by 3 because it's not going to be

709
00:37:14,380 --> 00:37:16,969
immediately obvious to them why you did

710
00:37:15,969 --> 00:37:18,440
that

711
00:37:16,440 --> 00:37:20,460
they're not going to immediately say oh

712
00:37:18,460 --> 00:37:24,619
they're left shifting by 3 because they

713
00:37:20,619 --> 00:37:26,429
want to divide by 8 okay they either say

714
00:37:24,429 --> 00:37:27,110
why am i left shifting by 3 like

715
00:37:26,110 --> 00:37:30,309
some people may look at that and go

716
00:37:27,309 --> 00:37:31,460
what's going on with the arrows right

717
00:37:30,460 --> 00:37:33,599
it's an application programmer who

718
00:37:31,599 --> 00:37:35,849
doesn't do bit stuff right somebody else

719
00:37:33,849 --> 00:37:38,650
may look at it and think oh I'm doing

720
00:37:35,650 --> 00:37:41,769
the bitwise shift what is this and this

721
00:37:38,769 --> 00:37:42,559
is obviously not a number and somebody

722
00:37:41,559 --> 00:37:43,820
else will eventually realize that you're

723
00:37:42,820 --> 00:37:46,809
doing that because you're trying to

724
00:37:43,809 --> 00:37:48,210
divide by a power - okay here's the

725
00:37:46,210 --> 00:37:50,400
thing you go ahead and do it divided by

726
00:37:48,400 --> 00:37:54,650
a power of two in this magical piece of

727
00:37:50,650 --> 00:37:58,840
software the compiler will say aha

728
00:37:54,840 --> 00:37:59,059
that's a power of two I'm going to

729
00:37:58,059 --> 00:38:03,789
convert this to a left shift for them

730
00:37:59,789 --> 00:38:07,480
and so if you write your code as normal

731
00:38:03,480 --> 00:38:14,590
you get the benefit of both worlds

732
00:38:07,590 --> 00:38:16,710
readable code and fast code so why do we

733
00:38:14,710 --> 00:38:18,300
talk about this we talk about this

734
00:38:16,300 --> 00:38:20,070
because if you go back for whatever

735
00:38:18,070 --> 00:38:22,710
reason and read the assembly that the

736
00:38:20,710 --> 00:38:24,659
compiler generated for your code or

737
00:38:22,659 --> 00:38:26,400
debug into the assembly that the

738
00:38:24,400 --> 00:38:28,289
compiler generated for your code you may

739
00:38:26,289 --> 00:38:30,239
sometimes see where you had a divided by

740
00:38:28,239 --> 00:38:32,250
a power of two and it replaced it with a

741
00:38:30,250 --> 00:38:33,139
left shift well you had to multiply by a

742
00:38:32,139 --> 00:38:36,940
power of two and it replaced it with the

743
00:38:33,940 --> 00:38:39,400
right shift does that make sense and

744
00:38:36,400 --> 00:38:42,309
that should not mystify you because you

745
00:38:39,309 --> 00:38:43,010
should know that power of two

746
00:38:42,010 --> 00:38:45,239
multiplication division can be

747
00:38:43,239 --> 00:38:48,309
represented as shifts does that make

748
00:38:45,309 --> 00:38:56,489
sense and the compiler will do this for

749
00:38:48,489 --> 00:38:58,110
you okay okay most machines shift in

750
00:38:56,110 --> 00:39:00,300
that fast the multiply the compiler

751
00:38:58,300 --> 00:39:02,880
generates this code for you you don't

752
00:39:00,880 --> 00:39:05,170
write it this way because it makes your

753
00:39:02,170 --> 00:39:08,940
code less readable and gains you nothing

754
00:39:05,940 --> 00:39:10,230
because the compiler will do this for

755
00:39:08,230 --> 00:39:12,300
you having said that when you're looking

756
00:39:10,300 --> 00:39:14,309
at code and see things that are left

757
00:39:12,309 --> 00:39:15,199
shifts and right shifts you should think

758
00:39:14,199 --> 00:39:22,489
left shift and right shift and then you

759
00:39:15,489 --> 00:39:25,050
should think divide and multiply okay

760
00:39:22,050 --> 00:39:29,320
power of two divide if we imagine a

761
00:39:25,320 --> 00:39:30,039
binary point imagine integer

762
00:39:29,039 --> 00:39:31,719
multiplication know binary point we'll

763
00:39:30,719 --> 00:39:35,860
see the problem that I was talking about

764
00:39:31,860 --> 00:39:39,369
before which is that a 1 here gets

765
00:39:35,369 --> 00:39:40,179
shifted off to there some like to say it

766
00:39:39,179 --> 00:39:43,710
gets truncated the reality is it just

767
00:39:40,710 --> 00:39:48,739
goes away all right if we want to fix

768
00:39:43,739 --> 00:39:48,429
that problem what do we do

769
00:39:53,429 --> 00:40:00,230
you guys did it in like you know fourth

770
00:39:55,230 --> 00:40:03,480
grade when you learn rounding well let's

771
00:40:00,480 --> 00:40:03,269
have you don't wanna round down though

772
00:40:05,269 --> 00:40:12,980
okay so if we think about non-negative

773
00:40:07,980 --> 00:40:14,269
numbers if I always add one before I

774
00:40:12,269 --> 00:40:16,550
write shift I'm gonna guarantee that I'm

775
00:40:14,550 --> 00:40:18,230
gonna round up because if it's a zero

776
00:40:16,230 --> 00:40:20,300
and I put a 1 there if it's an even

777
00:40:18,300 --> 00:40:21,489
number already and I add a 1 I've done

778
00:40:20,489 --> 00:40:22,179
nothing to it

779
00:40:21,179 --> 00:40:25,588
that one gets thrown away when I write

780
00:40:22,588 --> 00:40:28,739
shift if however it's an odd number and

781
00:40:25,739 --> 00:40:34,588
I add 1 it's one of one that causes a

782
00:40:28,588 --> 00:40:36,139
carry then when I left shift I'm

783
00:40:34,139 --> 00:40:41,809
dropping a zero so I forced that half to

784
00:40:36,809 --> 00:40:42,059
get rounded up does that make sense

785
00:40:41,059 --> 00:40:45,989
you're allowed to come in you don't just

786
00:40:42,989 --> 00:40:49,780
down at the door you know what to go

787
00:40:45,780 --> 00:40:53,579
away either you're allowed to come in ok

788
00:40:49,579 --> 00:40:57,119
grab a seat make yourself at home

789
00:40:53,119 --> 00:40:57,298
alright so do you see how that works now

790
00:40:59,298 --> 00:41:08,389
let's take a funny case let's take the

791
00:41:03,389 --> 00:41:11,699
case of negative numbers let's say for a

792
00:41:08,699 --> 00:41:16,389
moment that I have a negative number and

793
00:41:11,389 --> 00:41:18,469
I right shift someone tell me what

794
00:41:16,469 --> 00:41:18,469
happens

795
00:41:19,469 --> 00:41:27,679
take out your paper give yourself a

796
00:41:22,679 --> 00:41:31,780
simple negative number and write shifted

797
00:41:27,780 --> 00:41:36,650
a negative number where there's a one in

798
00:41:31,650 --> 00:41:37,358
the rightmost bit all right yeah we're

799
00:41:36,358 --> 00:41:42,469
the medic we don't want to break it

800
00:41:37,469 --> 00:41:44,539
right your hand is up questions yeah we

801
00:41:42,539 --> 00:41:45,010
want to go ahead and order you know a

802
00:41:44,010 --> 00:41:48,900
medic shift so we don't intentionally

803
00:41:45,900 --> 00:41:55,719
break things I want to know which way

804
00:41:48,719 --> 00:41:57,289
this rounding now goes and now people

805
00:41:55,289 --> 00:42:00,840
telling me both up and down so it helps

806
00:41:57,840 --> 00:42:01,449
you actually write it out I know that

807
00:42:00,449 --> 00:42:04,920
you know pencil and paper like

808
00:42:01,920 --> 00:42:06,710
deprecated if you've got a tablet you

809
00:42:04,710 --> 00:42:08,090
can actually use your little stylus and

810
00:42:06,090 --> 00:42:10,219
write on the screen if you're limited to

811
00:42:08,219 --> 00:42:21,710
keyboards you know then that's okay you

812
00:42:10,710 --> 00:42:22,000
can type numbers too that works I don't

813
00:42:21,000 --> 00:42:24,190
get somebody in the back on this one

814
00:42:22,190 --> 00:42:25,480
I've been picking on the front corner

815
00:42:24,480 --> 00:42:34,250
right here

816
00:42:25,250 --> 00:42:34,139
Wow I don't know let's see

817
00:42:55,139 --> 00:43:01,268
I'm Greg

818
00:42:57,268 --> 00:43:10,929
Morgan nice to meet you Morgan so what

819
00:43:01,929 --> 00:43:12,150
do you think was one one zero zero once

820
00:43:10,150 --> 00:43:16,130
what do you think that represents in in

821
00:43:12,130 --> 00:43:18,559
terms of an integer value negative nine

822
00:43:16,559 --> 00:43:20,489
do you guys have brains give me a quick

823
00:43:18,489 --> 00:43:22,349
test one one zero zero one is that

824
00:43:20,349 --> 00:43:22,769
negative nine

825
00:43:31,769 --> 00:43:34,619
perfect

826
00:43:40,619 --> 00:43:43,340
it's like

827
00:43:50,340 --> 00:43:53,630
how many people think it's negative nine

828
00:43:52,630 --> 00:43:57,380
raise your hands

829
00:43:53,380 --> 00:44:00,519
I think it's negative seven raise your

830
00:43:57,519 --> 00:44:02,639
hands yeah so if we look at that one one

831
00:44:00,639 --> 00:44:04,980
zero zero one right the easy way to

832
00:44:02,980 --> 00:44:08,389
think of that is if it was all ones what

833
00:44:04,389 --> 00:44:10,170
would it be negative one but we don't we

834
00:44:08,170 --> 00:44:16,260
have two zeros there right

835
00:44:10,260 --> 00:44:19,300
four and two right so that's six so it's

836
00:44:16,300 --> 00:44:21,719
negative one minus six negative seven

837
00:44:19,719 --> 00:44:29,699
okay so we got a negative seven

838
00:44:21,699 --> 00:44:31,440
all right now what do you think okay so

839
00:44:29,440 --> 00:44:33,210
you're right shifted it by two and so we

840
00:44:31,210 --> 00:44:37,070
lose that rightmost one bit it's now it

841
00:44:33,070 --> 00:44:39,179
becomes four ones one one one one zero

842
00:44:37,179 --> 00:44:43,940
zero now if we take a look at there at

843
00:44:39,940 --> 00:44:46,420
the result there it's one one one one

844
00:44:43,420 --> 00:44:47,570
zero I'm sorry okay so now if we take a

845
00:44:46,570 --> 00:44:50,800
look at that it's the same as all ones

846
00:44:47,800 --> 00:44:52,050
which would be negative one right minus

847
00:44:50,050 --> 00:44:55,000
1 which is negative 2 so which way did

848
00:44:52,000 --> 00:44:58,150
that round when you say down what do you

849
00:44:55,150 --> 00:45:02,599
mean these are two ways of looking at

850
00:44:58,599 --> 00:45:06,050
this there is closer to zero versus

851
00:45:02,050 --> 00:45:11,219
farther from zero and there is down as

852
00:45:06,219 --> 00:45:13,050
in more negative rounds closer to zero

853
00:45:11,050 --> 00:45:16,360
how do you agree that it rounds closer

854
00:45:13,360 --> 00:45:16,940
to zero raise your hands

855
00:45:19,940 --> 00:45:32,030
how many people disagree that it rounds

856
00:45:23,030 --> 00:45:39,539
close to zero raise your hands hmm so

857
00:45:32,539 --> 00:45:42,920
let's take a minute and write it out I'm

858
00:45:39,920 --> 00:45:42,349
just gonna hang out and relax

859
00:45:49,349 --> 00:45:55,759
so this original number represented what

860
00:45:51,759 --> 00:46:07,568
rated out in thing up so this number

861
00:45:55,568 --> 00:46:10,630
that you now have represents what and if

862
00:46:07,630 --> 00:46:12,239
you would have added that one if it so

863
00:46:10,239 --> 00:46:13,730
that so that was okay so that would be

864
00:46:12,730 --> 00:46:18,960
if we did that way that would be

865
00:46:13,960 --> 00:46:23,000
negative three and a half right negative

866
00:46:18,000 --> 00:46:27,048
7/2 would be nominally negative three

867
00:46:23,048 --> 00:46:27,420
and half so right that way thanks to us

868
00:46:42,420 --> 00:46:46,809
looks like everybody else did it first

869
00:46:48,809 --> 00:46:52,139
yes

870
00:46:50,139 --> 00:46:56,568
oh he register before that's fine yeah

871
00:46:52,568 --> 00:46:59,469
so you actually have you do you divide

872
00:46:56,469 --> 00:47:00,289
by 2 or bucks by 4 okay everything I

873
00:46:59,289 --> 00:47:04,760
think I totally bring else into my bike

874
00:47:00,760 --> 00:47:16,119
- so let's do this yeah so now that

875
00:47:04,119 --> 00:47:17,510
becomes where's this actually okay hey

876
00:47:16,510 --> 00:47:19,858
guys that Joy's an inconsistent a year

877
00:47:17,858 --> 00:47:21,420
we should be dividing by we should be

878
00:47:19,420 --> 00:47:22,338
dividing by four because that's what he

879
00:47:21,338 --> 00:47:24,750
said he shifted by two that's divided by

880
00:47:22,750 --> 00:47:25,338
four let's put it back to the example

881
00:47:24,338 --> 00:47:28,579
yeah

882
00:47:25,579 --> 00:47:28,880
[Applause]

883
00:47:32,880 --> 00:47:42,338
and then so what we have this is 7/4 is

884
00:47:36,338 --> 00:47:59,338
water to bed which are the transfers and

885
00:47:42,338 --> 00:48:03,259
decimals we have seven who lead is 7/4

886
00:47:59,259 --> 00:48:03,599
for now good enough and then what's this

887
00:48:10,599 --> 00:48:17,920
so all one's be negative one

888
00:48:12,920 --> 00:48:20,769
there's no one's negative okay what so

889
00:48:17,769 --> 00:48:20,119
this is negative two this is negative

890
00:48:20,119 --> 00:48:24,960
one or something

891
00:48:20,960 --> 00:48:34,769
we draw these on our number line that's

892
00:48:24,769 --> 00:48:38,190
my zero and this is 7/4 right and that's

893
00:48:34,190 --> 00:48:46,809
my negative two right and so which way

894
00:48:38,809 --> 00:48:48,789
to the count so it's more negative it's

895
00:48:46,789 --> 00:48:51,500
more negative we wear down as down as

896
00:48:48,500 --> 00:48:53,739
becomes ambiguous here right so it's

897
00:48:51,739 --> 00:48:55,480
definitely rounded more negative right

898
00:48:53,480 --> 00:48:58,579
which is not necessarily close to zero

899
00:48:55,579 --> 00:48:58,150
as it was before

900
00:48:58,150 --> 00:49:05,860
okay guys what do we think in this case

901
00:49:02,860 --> 00:49:10,989
when we took the the one one zero one

902
00:49:05,989 --> 00:49:12,429
one zero zero one the negative 7/4 right

903
00:49:10,429 --> 00:49:15,739
ideally in our minds this was gonna be

904
00:49:12,739 --> 00:49:16,469
negative 7/4 let's not worry about it

905
00:49:15,469 --> 00:49:19,579
beyond that point we need to break it

906
00:49:16,579 --> 00:49:23,550
down two fractions when we write shifted

907
00:49:19,550 --> 00:49:25,090
that 2/4 right and we write chipped it

908
00:49:23,090 --> 00:49:31,070
away the two might rightmost bits what

909
00:49:25,070 --> 00:49:32,849
did we end up with negative 2 so we

910
00:49:31,849 --> 00:49:38,989
think about that in the number line

911
00:49:32,989 --> 00:49:40,000
right we have negative 7/4 right which

912
00:49:38,000 --> 00:49:44,550
is less than 2 right and then we have

913
00:49:40,550 --> 00:49:48,599
negative 2 so when we rounded which way

914
00:49:44,599 --> 00:49:51,500
did we round we rounded a wafer we

915
00:49:48,500 --> 00:49:52,289
rounded more to the left right and at

916
00:49:51,289 --> 00:49:55,820
one level this is perfectly consistent

917
00:49:52,820 --> 00:49:57,610
right at one level when we were dealing

918
00:49:55,610 --> 00:49:58,110
on the positive side of the number lines

919
00:49:57,110 --> 00:50:05,760
not negative sides a number line and we

920
00:49:58,760 --> 00:50:07,570
rounded which way do we go left now we

921
00:50:05,570 --> 00:50:09,789
rounding the same we rounding on the

922
00:50:07,789 --> 00:50:12,320
other side of the number line but using

923
00:50:09,320 --> 00:50:14,530
the same mathematical rules right which

924
00:50:12,530 --> 00:50:17,179
way do we shift which way is that

925
00:50:14,179 --> 00:50:18,780
there's a rounding go left everybody

926
00:50:17,780 --> 00:50:21,889
agreed

927
00:50:18,889 --> 00:50:22,960
so it's perfectly consistent in terms of

928
00:50:21,960 --> 00:50:25,889
the way meant you'd expect a

929
00:50:22,889 --> 00:50:28,409
mathematical operator to face its

930
00:50:25,409 --> 00:50:30,409
rounding left in either case the problem

931
00:50:28,409 --> 00:50:32,360
is to us humans it's less intuitive

932
00:50:30,360 --> 00:50:35,309
because on the right side of the number

933
00:50:32,309 --> 00:50:38,130
line its rounding down what we mean

934
00:50:35,130 --> 00:50:40,010
towards zero smaller absolute value and

935
00:50:38,010 --> 00:50:43,320
yet on the left side and underlined its

936
00:50:40,320 --> 00:50:46,320
rounding down we're now down means left

937
00:50:43,320 --> 00:50:50,409
or a greater absolute value do you see

938
00:50:46,409 --> 00:50:56,550
the paradox do you see why this math is

939
00:50:50,550 --> 00:50:58,130
just unfriendly to people okay left to

940
00:50:56,130 --> 00:51:02,590
its own devices rounding is always going

941
00:50:58,590 --> 00:51:04,340
to be to the left which means a greater

942
00:51:02,340 --> 00:51:06,289
absolute value for negative numbers and

943
00:51:04,289 --> 00:51:09,059
a smaller absolute value for the

944
00:51:06,059 --> 00:51:10,030
non-negative numbers if that's not the

945
00:51:09,030 --> 00:51:13,980
way we want the rounding to work we need

946
00:51:10,980 --> 00:51:14,409
to fix it in a negative case does that

947
00:51:13,409 --> 00:51:17,010
make sense

948
00:51:14,010 --> 00:51:19,670
or what fix it in the positive case by

949
00:51:17,670 --> 00:51:22,260
adding or subtracting something to make

950
00:51:19,260 --> 00:51:24,260
the math work out our way but it's

951
00:51:22,260 --> 00:51:27,840
naturally intuitively inconsistent to

952
00:51:24,840 --> 00:51:30,570
people because it's always rounding left

953
00:51:27,570 --> 00:51:33,000
rather than rounding towards zero in

954
00:51:30,000 --> 00:51:34,599
both cases which is what we'd want we'd

955
00:51:33,599 --> 00:51:37,739
want you to be able to take a positive

956
00:51:34,739 --> 00:51:39,889
four and a negative four divide you make

957
00:51:37,889 --> 00:51:41,210
a positive five and negative five

958
00:51:39,210 --> 00:51:43,280
divided each by two add them together

959
00:51:41,280 --> 00:51:47,860
and get zero and that's not what the

960
00:51:43,860 --> 00:51:49,369
president math allows because they're

961
00:51:47,369 --> 00:51:51,920
both getting rounded this way so one's

962
00:51:49,920 --> 00:51:53,510
getting a greater absolute value the

963
00:51:51,510 --> 00:51:55,070
negative one and the positive one's

964
00:51:53,070 --> 00:52:00,230
getting a smaller absolute value so when

965
00:51:55,230 --> 00:52:03,420
they're added the negative wins okay and

966
00:52:00,420 --> 00:52:04,659
that's what we're going with that and so

967
00:52:03,659 --> 00:52:11,739
if we want to correct it we need to add

968
00:52:04,739 --> 00:52:11,050
a bias and we talked about that okay

969
00:52:12,050 --> 00:52:19,199
okay

970
00:52:13,199 --> 00:52:19,019
so some basic rules of arithmetic we

971
00:52:19,019 --> 00:52:21,920
were dealing with signed or unsigned

972
00:52:19,920 --> 00:52:23,449
it's normal addition followed by a

973
00:52:21,449 --> 00:52:26,699
truncate and we talked about the

974
00:52:23,699 --> 00:52:29,639
consequences of that unsigned arithmetic

975
00:52:26,639 --> 00:52:31,369
is mod two signed arithmetic is is sort

976
00:52:29,369 --> 00:52:33,929
of mod two

977
00:52:31,929 --> 00:52:36,989
but then it gets weird right

978
00:52:33,989 --> 00:52:38,639
multiplication is basically normal

979
00:52:36,639 --> 00:52:40,650
multiplication followed by a truncate if

980
00:52:38,650 --> 00:52:43,869
it's unsigned as mod 2 if it's signed

981
00:52:40,869 --> 00:52:44,030
it's still like again basically mod 2

982
00:52:43,030 --> 00:52:45,590
but it gets weird because the number

983
00:52:44,590 --> 00:52:48,969
lines has been Rinat has been relabeled

984
00:52:45,969 --> 00:52:55,340
and we saw that we saw the way the plane

985
00:52:48,340 --> 00:52:57,960
shifted why should I use unsigned I'm

986
00:52:55,960 --> 00:53:00,699
gonna skip past that slide for a minute

987
00:52:57,699 --> 00:53:02,070
and the reason I'm gonna skip past that

988
00:53:00,070 --> 00:53:05,650
slides I think it's too simple if you're

989
00:53:02,650 --> 00:53:08,230
using unsigned numbers you get a much

990
00:53:05,230 --> 00:53:10,650
greater range because your number line

991
00:53:08,650 --> 00:53:13,900
starts at 0 and goes forward you're not

992
00:53:10,900 --> 00:53:17,679
shifting it to make it centered about 0

993
00:53:13,679 --> 00:53:21,500
in general this is good if you don't

994
00:53:17,500 --> 00:53:23,099
need negative numbers because now you

995
00:53:21,099 --> 00:53:24,079
can handle bigger numbers which means if

996
00:53:23,079 --> 00:53:27,429
you get bigger inputs than you expect

997
00:53:24,429 --> 00:53:29,070
you'll be able to handle them so a

998
00:53:27,070 --> 00:53:33,619
common type of advice is use unsigned

999
00:53:29,619 --> 00:53:36,750
numbers unless negatives can occur

1000
00:53:33,750 --> 00:53:38,579
however I need to warn you that

1001
00:53:36,579 --> 00:53:40,500
negatives occurring in the common case

1002
00:53:38,500 --> 00:53:44,840
is different than negatives occurring in

1003
00:53:40,840 --> 00:53:48,559
a case where something goes wrong so we

1004
00:53:44,559 --> 00:53:50,909
say use unsigned and less right you need

1005
00:53:48,909 --> 00:53:52,849
negative numbers we mean under any

1006
00:53:50,849 --> 00:53:54,900
circumstances you will encounter a

1007
00:53:52,900 --> 00:53:58,880
negative number a negative number is bad

1008
00:53:54,880 --> 00:53:59,300
input is one case because if somebody

1009
00:53:58,300 --> 00:54:01,980
gives you something like negative 5 and

1010
00:53:59,980 --> 00:54:05,480
you interpret that as a huge number

1011
00:54:01,480 --> 00:54:07,380
that's a problem okay if something goes

1012
00:54:05,380 --> 00:54:10,179
wrong with your system that should never

1013
00:54:07,179 --> 00:54:11,389
be freezing and now it is it'd be nice

1014
00:54:10,389 --> 00:54:13,920
to know that and not turn on the air

1015
00:54:11,920 --> 00:54:19,059
conditioner because you think it's too

1016
00:54:13,059 --> 00:54:21,000
hot right so we say use unsigned numbers

1017
00:54:19,000 --> 00:54:24,730
unless you need negative numbers we mean

1018
00:54:21,730 --> 00:54:28,309
you need negative numbers under any set

1019
00:54:24,309 --> 00:54:34,420
of circumstances including you being fed

1020
00:54:28,420 --> 00:54:36,329
badly does that make sense so it's

1021
00:54:34,329 --> 00:54:38,010
critical to ask yourself when choosing

1022
00:54:36,010 --> 00:54:40,650
the the data type you need which data

1023
00:54:38,650 --> 00:54:43,780
type is giving going to give me the most

1024
00:54:40,780 --> 00:54:45,269
robustness giving any data I can

1025
00:54:43,269 --> 00:54:48,760
encounter good and bad

1026
00:54:45,760 --> 00:54:53,710
and if you can use a larger data type

1027
00:54:48,710 --> 00:54:54,420
than you need why who cares if an

1028
00:54:53,420 --> 00:54:56,650
integer is a little bit bigger like

1029
00:54:54,650 --> 00:54:59,420
whatever if you've got plenty of memory

1030
00:54:56,420 --> 00:55:05,630
go with the long instead of an int now

1031
00:54:59,630 --> 00:55:10,780
you're safer oK we've got a whole bunch

1032
00:55:05,780 --> 00:55:13,750
of the classic c puzzles right and again

1033
00:55:10,750 --> 00:55:14,280
i'm gonna leave most of these for you to

1034
00:55:13,280 --> 00:55:16,780
play with because i don't think there's

1035
00:55:14,780 --> 00:55:26,010
a lot of good that comes out of me doing

1036
00:55:16,010 --> 00:55:32,150
puzzles for you what's that okay they're

1037
00:55:26,150 --> 00:55:35,809
not okay so at the end of the day we get

1038
00:55:32,809 --> 00:55:36,239
some value into X and we get some value

1039
00:55:35,239 --> 00:55:39,349
and Y we don't know where they come from

1040
00:55:36,349 --> 00:55:43,980
and now we have an unsigned u X and an

1041
00:55:39,980 --> 00:55:44,250
unsigned uy okay and now the question is

1042
00:55:43,250 --> 00:55:47,480
for each of the following expressions is

1043
00:55:44,480 --> 00:55:49,539
a true or false and why sort of like you

1044
00:55:47,539 --> 00:55:50,250
to do with these actually do them do

1045
00:55:49,250 --> 00:55:52,570
them on your own and if you have

1046
00:55:50,570 --> 00:55:53,130
questions get together your friends who

1047
00:55:52,130 --> 00:55:56,659
are doing them on my own and talk to

1048
00:55:53,659 --> 00:55:58,449
them study groups are amazing tools and

1049
00:55:56,449 --> 00:55:59,309
then that if you still have questions

1050
00:55:58,309 --> 00:56:01,750
because you and your friends are having

1051
00:55:59,750 --> 00:56:02,789
you know or are now wrestling each other

1052
00:56:01,789 --> 00:56:04,809
and beating each other up over the

1053
00:56:02,809 --> 00:56:06,940
correct answer come to office hours will

1054
00:56:04,940 --> 00:56:09,559
pull tables out of the way let you

1055
00:56:06,559 --> 00:56:11,079
wrestle for a while and then we'll

1056
00:56:09,079 --> 00:56:12,179
declare a winner not based upon who's

1057
00:56:11,179 --> 00:56:15,469
the most polite or who gets knocked out

1058
00:56:12,469 --> 00:56:17,380
but based upon what actually works and

1059
00:56:15,380 --> 00:56:19,179
then you'll have some fun and you'll

1060
00:56:17,179 --> 00:56:20,159
have your answers but really give them a

1061
00:56:19,159 --> 00:56:27,199
try yourself

1062
00:56:20,199 --> 00:56:29,469
okay we know that memory is byte

1063
00:56:27,469 --> 00:56:31,269
oriented this shouldn't shock or amaze

1064
00:56:29,269 --> 00:56:32,369
anybody okay

1065
00:56:31,369 --> 00:56:35,719
it should shock it amaze you to

1066
00:56:32,719 --> 00:56:37,119
understand that an address is nothing

1067
00:56:35,119 --> 00:56:39,130
more than offset into memory if we view

1068
00:56:37,130 --> 00:56:43,650
memory is one big array byte 0 byte 1

1069
00:56:39,650 --> 00:56:44,010
byte 2 by 3 by 4 by 5 by 6 by 7 when you

1070
00:56:43,010 --> 00:56:46,630
have a pointer all you have is an

1071
00:56:44,630 --> 00:56:50,250
integer that contains the offset from

1072
00:56:46,250 --> 00:56:57,710
the beginning of memory 473 bytes in

1073
00:56:50,710 --> 00:57:00,949
8192 bytes in right you'll send em to

1074
00:56:57,949 --> 00:57:02,320
you the phrase word size right when you

1075
00:57:00,320 --> 00:57:04,059
actually go to build a processor right

1076
00:57:02,059 --> 00:57:06,159
you have to design a data path that can

1077
00:57:04,159 --> 00:57:08,619
accommodate data up to a certain size so

1078
00:57:06,619 --> 00:57:10,539
you could move it between memory in the

1079
00:57:08,539 --> 00:57:12,909
processor easily okay you need to define

1080
00:57:10,909 --> 00:57:14,619
a sort of a hardware variable called a

1081
00:57:12,619 --> 00:57:16,000
register and it needs to have a certain

1082
00:57:14,000 --> 00:57:18,639
basic size and in general you want your

1083
00:57:16,639 --> 00:57:21,349
data path to be able to accommodate a

1084
00:57:18,349 --> 00:57:24,889
full register worth of data ok that

1085
00:57:21,889 --> 00:57:26,409
defines the word size of the system how

1086
00:57:24,409 --> 00:57:28,000
big are the registers and how big is the

1087
00:57:26,000 --> 00:57:29,280
data path so generally speaking your

1088
00:57:28,280 --> 00:57:31,869
registers your pointers and your data

1089
00:57:29,869 --> 00:57:33,460
for the rest of your data path are all

1090
00:57:31,460 --> 00:57:36,170
the same size and that's called the word

1091
00:57:33,170 --> 00:57:38,559
size ok now sometimes you have data

1092
00:57:36,559 --> 00:57:41,960
types that are larger than that and they

1093
00:57:38,960 --> 00:57:42,300
just require more than one path you know

1094
00:57:41,300 --> 00:57:47,650
in some way shape or form through the

1095
00:57:42,650 --> 00:57:49,619
data bus in order to deal with that ok

1096
00:57:47,619 --> 00:57:51,760
but the systems are designed to handle

1097
00:57:49,760 --> 00:57:54,889
data up to a certain size a 32-bit

1098
00:57:51,889 --> 00:57:56,199
system the registers the data path 32

1099
00:57:54,199 --> 00:57:57,389
bits if you need to deal with more than

1100
00:57:56,389 --> 00:58:00,889
that you need to deal with some how do

1101
00:57:57,889 --> 00:58:03,710
your math in a more complicated way

1102
00:58:00,710 --> 00:58:05,858
using 32-bit registers ok give it up

1103
00:58:03,858 --> 00:58:08,150
64-bit numbers we have to deal with

1104
00:58:05,150 --> 00:58:10,210
those 32-bit registers ok a 64-bit

1105
00:58:08,210 --> 00:58:19,190
system the registers and data path and

1106
00:58:10,190 --> 00:58:21,608
whatnot 64 bits wide ok this slide is

1107
00:58:19,608 --> 00:58:23,920
really confusing the only thing you

1108
00:58:21,920 --> 00:58:25,239
should get from this slide is that

1109
00:58:23,239 --> 00:58:27,309
memory is byte oriented not word

1110
00:58:25,309 --> 00:58:31,858
oriented so even if I'm dealing with an

1111
00:58:27,858 --> 00:58:32,309
integer that's four bytes large ok

1112
00:58:31,309 --> 00:58:35,750
even if I'm dealing with a 32-bit system

1113
00:58:32,750 --> 00:58:38,510
or a 64-bit system my addresses are

1114
00:58:35,510 --> 00:58:40,719
still byte addresses it doesn't matter

1115
00:58:38,719 --> 00:58:43,369
that my system uses a four byte data

1116
00:58:40,369 --> 00:58:45,190
type my addresses are still measured in

1117
00:58:43,190 --> 00:58:50,949
single bytes a pointer still measures

1118
00:58:45,949 --> 00:58:54,539
the total number of bytes from 0 so this

1119
00:58:50,539 --> 00:58:54,579
is not the right way to think of memory

1120
00:58:54,579 --> 00:59:01,420
this is it is in fact true that if you

1121
00:58:59,420 --> 00:59:03,519
present some weird address you may be

1122
00:59:01,519 --> 00:59:05,159
somewhere in the middle of a data type

1123
00:59:03,159 --> 00:59:08,119
you may be in the middle of an integer

1124
00:59:05,119 --> 00:59:09,389
right but you can still present that bad

1125
00:59:08,389 --> 00:59:10,230
pointer

1126
00:59:09,230 --> 00:59:12,849
and then the system will still choke on

1127
00:59:10,849 --> 00:59:15,769
it right because you presented a bad

1128
00:59:12,769 --> 00:59:19,829
pointer but the addresses are going to

1129
00:59:15,829 --> 00:59:23,608
name an offset from zero in memory not

1130
00:59:19,608 --> 00:59:25,809
some multiple of a datatype and this is

1131
00:59:23,809 --> 00:59:26,010
critically important because even though

1132
00:59:25,010 --> 00:59:29,389
my system may be able to accommodate a

1133
00:59:26,389 --> 00:59:32,199
64-bit integer a char is still one byte

1134
00:59:29,199 --> 00:59:38,989
eight bits right you have to be able to

1135
00:59:32,989 --> 00:59:41,750
get to the small things you know if

1136
00:59:38,750 --> 00:59:43,329
we're talking about C C's define several

1137
00:59:41,329 --> 00:59:44,130
types in several datatypes charge sorts

1138
00:59:43,130 --> 00:59:47,690
ends Long's Long's long Sloat's doubles

1139
00:59:44,690 --> 00:59:50,480
long doubles and pointers and our

1140
00:59:47,480 --> 00:59:52,210
typical 32-bit system we see the chars

1141
00:59:50,210 --> 00:59:52,369
are one byte shorts or 2 bytes insert 4

1142
00:59:52,369 --> 00:59:54,789
bytes

1143
00:59:52,789 --> 00:59:57,889
since it's a 32-bit system Long's are

1144
00:59:54,889 --> 00:59:59,050
still 4 bytes long Long's are now 8

1145
00:59:57,050 --> 00:00:01,659
bytes floats or 4 bytes doubles are

1146
00:59:59,659 --> 00:00:04,960
gonna be double the float or a fights

1147
01:00:01,960 --> 01:00:07,760
long double still eight bytes pointers

1148
01:00:04,760 --> 01:00:09,880
four bytes okay on a 32-bit system your

1149
01:00:07,880 --> 01:00:12,199
pointer size gonna be the same as your

1150
01:00:09,199 --> 01:00:15,858
data path size all right you know the

1151
01:00:12,858 --> 01:00:18,409
Intel 30 the Intel system it's basically

1152
01:00:15,409 --> 01:00:19,079
mirrors that right except for the fact

1153
01:00:18,079 --> 01:00:21,670
we see funding and funding this on a so

1154
01:00:19,670 --> 01:00:22,619
called long double and we'll talk about

1155
01:00:21,619 --> 01:00:24,909
that but that's because there's night

1156
01:00:22,909 --> 01:00:26,679
ripoli standard that applies to

1157
01:00:24,679 --> 01:00:30,599
floating-point numbers and the Intel

1158
01:00:26,599 --> 01:00:32,338
system is able to accommodate that okay

1159
01:00:30,338 --> 01:00:34,869
and then if we look at the 64-bit system

1160
01:00:32,869 --> 01:00:36,670
we see that in general the data types

1161
01:00:34,670 --> 01:00:39,108
are the same size they were on the

1162
01:00:36,108 --> 01:00:42,909
32-bit system right one two four eight

1163
01:00:39,909 --> 01:00:45,800
but now we see that the long actually is

1164
01:00:42,800 --> 01:00:46,139
eight now it's actually able to be

1165
01:00:45,139 --> 01:00:49,940
double the size of the end a long long

1166
01:00:46,940 --> 01:00:52,099
is still eight floats or doubles or

1167
01:00:49,099 --> 01:00:54,039
eight long doubles are now able to

1168
01:00:52,039 --> 01:00:56,739
accommodate that you know the same 10

1169
01:00:54,739 --> 01:00:57,358
bit standard now an additional 16 bit

1170
01:00:56,358 --> 01:00:59,858
standard and we'll talk about that we

1171
01:00:57,858 --> 01:01:00,059
talk about floating floating point

1172
01:00:59,059 --> 01:01:03,949
numbers pointers are now eight bits

1173
01:01:00,949 --> 01:01:04,019
instead of instead of four because we

1174
01:01:03,019 --> 01:01:06,639
now have we now the ability to have

1175
01:01:04,639 --> 01:01:15,679
64-bit addresses because we have a

1176
01:01:06,679 --> 01:01:19,809
64-bit data path byte ordering

1177
01:01:15,809 --> 01:01:21,119
so if you think about it and you think

1178
01:01:19,119 --> 01:01:22,039
about a binary number the least

1179
01:01:21,039 --> 01:01:25,298
significant bits are on the right

1180
01:01:22,298 --> 01:01:28,268
correct and the most significant bits

1181
01:01:25,268 --> 01:01:32,298
are on the left the same is true for

1182
01:01:28,298 --> 01:01:36,650
decimal numbers right my ones place is

1183
01:01:32,650 --> 01:01:40,248
here tens hundreds thousands small was

1184
01:01:36,248 --> 01:01:42,630
on the right big is on the left if

1185
01:01:40,630 --> 01:01:45,838
however I would ask you to label things

1186
01:01:42,838 --> 01:01:48,608
you would label the first the second the

1187
01:01:45,608 --> 01:01:49,309
third the fourth the fifth you would

1188
01:01:48,309 --> 01:01:54,920
count from the left to the right

1189
01:01:49,920 --> 01:01:58,460
everybody agree so there are two

1190
01:01:54,460 --> 01:02:00,179
different ways we can number bytes if I

1191
01:01:58,179 --> 01:02:02,429
say integer has four bytes it's logical

1192
01:02:00,429 --> 01:02:04,338
that I number them zero one two three

1193
01:02:02,338 --> 01:02:05,389
because that's how we normally number

1194
01:02:04,389 --> 01:02:08,920
things or it's logical I number them

1195
01:02:05,920 --> 01:02:11,230
zero one two three because that's how we

1196
01:02:08,230 --> 01:02:13,980
count bits and digits in a number so we

1197
01:02:11,980 --> 01:02:15,389
have two different numbering systems we

1198
01:02:13,389 --> 01:02:19,759
use big-endian and little-endian

1199
01:02:15,759 --> 01:02:28,349
depending on which way we do this okay

1200
01:02:19,349 --> 01:02:30,748
big endian you see right if we take

1201
01:02:28,748 --> 01:02:33,909
something that's that's that's you know

1202
01:02:30,909 --> 01:02:35,068
zero one two three four five six seven

1203
01:02:33,068 --> 01:02:38,739
you see with big endian zero one two

1204
01:02:35,739 --> 01:02:40,920
three four five six seven the bytes go

1205
01:02:38,920 --> 01:02:46,900
from the left to the right that is to

1206
01:02:40,900 --> 01:02:52,239
say the big is at the end little endian

1207
01:02:46,239 --> 01:02:57,268
flips the bytes but not the bits each

1208
01:02:52,268 --> 01:03:01,219
individual byte 8-bit grouping stays the

1209
01:02:57,219 --> 01:03:06,059
same but the ordering of those bytes is

1210
01:03:01,059 --> 01:03:09,608
now flipped zero one two three four five

1211
01:03:06,608 --> 01:03:09,599
six seven

1212
01:03:10,599 --> 01:03:13,849
okay

1213
01:03:14,849 --> 01:03:20,980
Intel machines for example use one

1214
01:03:17,980 --> 01:03:23,559
ordering Sun machines use another

1215
01:03:20,559 --> 01:03:25,349
ordering if you send the value over the

1216
01:03:23,349 --> 01:03:28,570
network from one machine to another this

1217
01:03:25,570 --> 01:03:31,559
becomes important if you write a value

1218
01:03:28,559 --> 01:03:33,780
to a file and read it on another system

1219
01:03:31,780 --> 01:03:37,849
it becomes important if you're in a

1220
01:03:33,849 --> 01:03:40,840
debugger it becomes important okay

1221
01:03:37,840 --> 01:03:42,329
otherwise we don't have to care because

1222
01:03:40,329 --> 01:03:44,070
the value is the value if I if I get

1223
01:03:42,070 --> 01:03:46,380
them if the value is 19 the value is 19

1224
01:03:44,380 --> 01:03:54,119
this system interprets the bits

1225
01:03:46,119 --> 01:03:56,940
correctly okay so you can see that

1226
01:03:54,940 --> 01:03:59,050
systems that use different byte

1227
01:03:56,050 --> 01:04:04,260
orderings the bytes get flipped but the

1228
01:03:59,260 --> 01:04:05,000
individual bits do not okay and so we

1229
01:04:04,000 --> 01:04:07,139
could write a quick little program and

1230
01:04:05,139 --> 01:04:13,090
see that just walks through and shows us

1231
01:04:07,090 --> 01:04:16,739
this okay we can see this in a debugger

1232
01:04:13,739 --> 01:04:17,329
okay it's important when you're doing

1233
01:04:16,329 --> 01:04:19,739
things like the like you're doing the

1234
01:04:17,739 --> 01:04:21,809
view you do the bomb lab next right

1235
01:04:19,809 --> 01:04:23,159
where you'll actually be able to edit

1236
01:04:21,159 --> 01:04:25,769
the build debugger looking at it and it

1237
01:04:23,769 --> 01:04:29,929
actually gets really confusing because

1238
01:04:25,929 --> 01:04:31,170
as it turns out gdb keeps the same byte

1239
01:04:29,170 --> 01:04:32,480
ordering regardless of what type of

1240
01:04:31,480 --> 01:04:36,980
system it's being used on because it's a

1241
01:04:32,980 --> 01:04:38,070
portable debugger and so it will reverse

1242
01:04:36,070 --> 01:04:41,860
the bytes for you so depending upon how

1243
01:04:38,860 --> 01:04:42,230
you look at it it will either be native

1244
01:04:41,230 --> 01:04:44,639
in which case it'll be big ending in a

1245
01:04:42,639 --> 01:04:47,920
little endian or the way gdb renders it

1246
01:04:44,920 --> 01:04:49,079
and so you've got to be really careful

1247
01:04:47,079 --> 01:04:52,150
to make sure you know what is the system

1248
01:04:49,150 --> 01:04:53,000
doing what are my tools doing and that

1249
01:04:52,000 --> 01:04:54,860
will help you find values in the in you

1250
01:04:53,860 --> 01:04:59,909
know when you're doing things like

1251
01:04:54,909 --> 01:05:01,230
debugging assembly pointers well 32-bit

1252
01:04:59,230 --> 01:05:01,630
pointers in 32-bit 64-bit pointers or 64

1253
01:05:01,630 --> 01:05:03,929
bits

1254
01:05:01,929 --> 01:05:06,369
they're basically integers with an

1255
01:05:03,369 --> 01:05:10,280
offset from zero and so the Indian rules

1256
01:05:06,280 --> 01:05:14,780
apply there to strings the thing to know

1257
01:05:10,780 --> 01:05:18,230
about strings is that strings in C are

1258
01:05:14,230 --> 01:05:20,010
arrays of characters the idea of a

1259
01:05:18,010 --> 01:05:24,409
string is mostly created by C's

1260
01:05:20,409 --> 01:05:27,400
libraries okay it 98% does not exist in

1261
01:05:24,400 --> 01:05:28,099
the C language proper the only way it

1262
01:05:27,099 --> 01:05:30,570
exists in the C language proper

1263
01:05:28,570 --> 01:05:35,460
is that a string literal exists you

1264
01:05:30,460 --> 01:05:36,199
could say quote ABCD quote and with that

1265
01:05:35,199 --> 01:05:45,880
represent is a character array

1266
01:05:36,880 --> 01:05:48,789
containing a b c d and null the bit

1267
01:05:45,789 --> 01:05:51,219
pattern 0 okay

1268
01:05:48,219 --> 01:05:55,579
strings in c are null terminated so if

1269
01:05:51,579 --> 01:05:59,179
you if you of the string ABCD ABCD that

1270
01:05:55,179 --> 01:06:01,289
is 5 bytes large for for the ABCD and a

1271
01:05:59,289 --> 01:06:03,289
fifth one for the null termination

1272
01:06:01,289 --> 01:06:05,309
that's how when you pass it into a

1273
01:06:03,309 --> 01:06:14,500
library it knows for example in printf

1274
01:06:05,500 --> 01:06:16,130
how many to print a b c d no stop ok

1275
01:06:14,130 --> 01:06:19,719
there's no byte ordering issue and it's

1276
01:06:16,719 --> 01:06:20,150
in with strings because strings are one

1277
01:06:19,150 --> 01:06:26,860
byte flip that byte however you want

1278
01:06:20,860 --> 01:06:26,289
it's still the same byte okay

1279
01:06:28,289 --> 01:06:34,599
so code security example when you're

1280
01:06:31,599 --> 01:06:36,119
passing things into functions data types

1281
01:06:34,119 --> 01:06:38,099
matter because if somebody passes in a

1282
01:06:36,099 --> 01:06:41,889
big type a big value into a function

1283
01:06:38,889 --> 01:06:43,010
that has an unsigned type or something

1284
01:06:41,010 --> 01:06:46,449
that big value can now look really

1285
01:06:43,449 --> 01:06:49,750
negative if you're expecting up to a 5

1286
01:06:46,750 --> 01:06:51,179
byte string and someone passes in a ten

1287
01:06:49,179 --> 01:06:53,639
Duyck string as will learn come buff lab

1288
01:06:51,639 --> 01:06:57,559
it can overwrite extra bytes in memory

1289
01:06:53,559 --> 01:06:59,130
generating a security concern so at the

1290
01:06:57,130 --> 01:07:02,369
low level these things actually matter

1291
01:06:59,369 --> 01:07:05,980
ok bonus extras are slides that we don't

1292
01:07:02,980 --> 01:07:10,039
actually use what we leave in the deck

1293
01:07:05,039 --> 01:07:12,480
so do you guys have any questions all

1294
01:07:10,480 --> 01:07:15,519
right have a great day everybody

1295
01:07:12,519 --> 01:07:15,000
take good care
Subtitles End: mo.dbxdb.com

